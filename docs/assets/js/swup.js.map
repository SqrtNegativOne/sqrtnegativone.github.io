{
  "version": 3,
  "sources": ["../../../node_modules/delegate-it/delegate.js", "../../../node_modules/swup/src/helpers/classify.ts", "../../../node_modules/swup/src/helpers/getCurrentUrl.ts", "../../../node_modules/swup/src/helpers/history.ts", "../../../node_modules/swup/src/helpers/delegateEvent.ts", "../../../node_modules/swup/src/helpers/Location.ts", "../../../node_modules/swup/src/helpers/matchPath.ts", "../../../node_modules/swup/src/modules/fetchPage.ts", "../../../node_modules/swup/src/modules/Cache.ts", "../../../node_modules/swup/src/utils/index.ts", "../../../node_modules/swup/src/modules/Classes.ts", "../../../node_modules/swup/src/modules/Visit.ts", "../../../node_modules/swup/src/modules/Hooks.ts", "../../../node_modules/swup/src/modules/getAnchorElement.ts", "../../../node_modules/swup/src/modules/awaitAnimations.ts", "../../../node_modules/swup/src/modules/navigate.ts", "../../../node_modules/swup/src/modules/animatePageOut.ts", "../../../node_modules/swup/src/modules/replaceContent.ts", "../../../node_modules/swup/src/modules/scrollToContent.ts", "../../../node_modules/swup/src/modules/animatePageIn.ts", "../../../node_modules/swup/src/modules/renderPage.ts", "../../../node_modules/swup/src/modules/plugins.ts", "../../../node_modules/swup/src/modules/resolveUrl.ts", "../../../node_modules/swup/src/Swup.ts", "../../../node_modules/@swup/plugin/src/versionSatisfies.ts", "../../../node_modules/@swup/plugin/src/index.ts", "../../../node_modules/@swup/plugin/src/pluginRequirements.ts", "../../../node_modules/@swup/theme/src/index.ts", "../../../node_modules/@swup/fade-theme/src/index.js", "../../../src/assets/js/swup.js"],
  "sourcesContent": ["/** Keeps track of raw listeners added to the base elements to avoid duplication */\nconst ledger = new WeakMap();\nfunction editLedger(wanted, baseElement, callback, setup) {\n    if (!wanted && !ledger.has(baseElement)) {\n        return false;\n    }\n    const elementMap = ledger.get(baseElement)\n        ?? new WeakMap();\n    ledger.set(baseElement, elementMap);\n    const setups = elementMap.get(callback) ?? new Set();\n    elementMap.set(callback, setups);\n    const existed = setups.has(setup);\n    if (wanted) {\n        setups.add(setup);\n    }\n    else {\n        setups.delete(setup);\n    }\n    return existed && wanted;\n}\nfunction safeClosest(event, selector) {\n    let target = event.target;\n    if (target instanceof Text) {\n        target = target.parentElement;\n    }\n    if (target instanceof Element && event.currentTarget instanceof Element) {\n        // `.closest()` may match ancestors of `currentTarget` but we only need its children\n        const closest = target.closest(selector);\n        if (closest && event.currentTarget.contains(closest)) {\n            return closest;\n        }\n    }\n}\n// This type isn't exported as a declaration, so it needs to be duplicated above\nfunction delegate(selector, type, callback, options = {}) {\n    const { signal, base = document } = options;\n    if (signal?.aborted) {\n        return;\n    }\n    // Don't pass `once` to `addEventListener` because it needs to be handled in `delegate-it`\n    const { once, ...nativeListenerOptions } = options;\n    // `document` should never be the base, it's just an easy way to define \"global event listeners\"\n    const baseElement = base instanceof Document ? base.documentElement : base;\n    // Handle the regular Element usage\n    const capture = Boolean(typeof options === 'object' ? options.capture : options);\n    const listenerFunction = (event) => {\n        const delegateTarget = safeClosest(event, String(selector));\n        if (delegateTarget) {\n            const delegateEvent = Object.assign(event, { delegateTarget });\n            callback.call(baseElement, delegateEvent);\n            if (once) {\n                baseElement.removeEventListener(type, listenerFunction, nativeListenerOptions);\n                editLedger(false, baseElement, callback, setup);\n            }\n        }\n    };\n    const setup = JSON.stringify({ selector, type, capture });\n    const isAlreadyListening = editLedger(true, baseElement, callback, setup);\n    if (!isAlreadyListening) {\n        baseElement.addEventListener(type, listenerFunction, nativeListenerOptions);\n    }\n    signal?.addEventListener('abort', () => {\n        editLedger(false, baseElement, callback, setup);\n    });\n}\nexport default delegate;\n", "/** Turn a string into a slug by lowercasing and replacing whitespace. */\nexport const classify = (text: string, fallback?: string): string => {\n\tconst output = String(text)\n\t\t.toLowerCase()\n\t\t// .normalize('NFD') // split an accented letter in the base letter and the acent\n\t\t// .replace(/[\\u0300-\\u036f]/g, '') // remove all previously split accents\n\t\t.replace(/[\\s/_.]+/g, '-') // replace spaces and _./ with '-'\n\t\t.replace(/[^\\w-]+/g, '') // remove all non-word chars\n\t\t.replace(/--+/g, '-') // replace repeating '-' with single '-'\n\t\t.replace(/^-+|-+$/g, ''); // trim '-' from edges\n\treturn output || fallback || '';\n};\n", "/** Get the current page URL: path name + query params. Optionally including hash. */\nexport const getCurrentUrl = ({ hash }: { hash?: boolean } = {}): string => {\n\treturn window.location.pathname + window.location.search + (hash ? window.location.hash : '');\n};\n", "import { getCurrentUrl } from './getCurrentUrl.js';\n\nexport interface HistoryState {\n\turl: string;\n\tsource: 'swup';\n\trandom: number;\n\tindex?: number;\n\t[key: string]: unknown;\n}\n\ntype HistoryData = Record<string, unknown>;\n\n/** Create a new history record with a custom swup identifier. */\nexport const createHistoryRecord = (url: string, data: HistoryData = {}): void => {\n\turl = url || getCurrentUrl({ hash: true });\n\tconst state: HistoryState = {\n\t\turl,\n\t\trandom: Math.random(),\n\t\tsource: 'swup',\n\t\t...data\n\t};\n\twindow.history.pushState(state, '', url);\n};\n\n/** Update the current history record with a custom swup identifier. */\nexport const updateHistoryRecord = (url: string | null = null, data: HistoryData = {}): void => {\n\turl = url || getCurrentUrl({ hash: true });\n\tconst currentState = (window.history.state as HistoryState) || {};\n\tconst state: HistoryState = {\n\t\t...currentState,\n\t\turl,\n\t\trandom: Math.random(),\n\t\tsource: 'swup',\n\t\t...data\n\t};\n\twindow.history.replaceState(state, '', url);\n};\n", "import delegate, {\n\ttype DelegateEventHandler,\n\ttype DelegateOptions,\n\ttype EventType\n} from 'delegate-it';\nimport type { ParseSelector } from 'typed-query-selector/parser.js';\n\nexport type DelegateEventUnsubscribe = {\n\tdestroy: () => void;\n};\n\n/** Register a delegated event listener. */\nexport const delegateEvent = <\n\tSelector extends string,\n\tTElement extends Element = ParseSelector<Selector, HTMLElement>,\n\tTEvent extends EventType = EventType\n>(\n\tselector: Selector,\n\ttype: TEvent,\n\tcallback: DelegateEventHandler<GlobalEventHandlersEventMap[TEvent], TElement>,\n\toptions?: DelegateOptions\n): DelegateEventUnsubscribe => {\n\tconst controller = new AbortController();\n\toptions = { ...options, signal: controller.signal };\n\tdelegate<Selector, TElement, TEvent>(selector, type, callback, options);\n\treturn { destroy: () => controller.abort() };\n};\n", "/**\n * A helper for creating a Location from either an element\n * or a URL object/string\n *\n */\nexport class Location extends URL {\n\tconstructor(url: URL | string, base: string = document.baseURI) {\n\t\tsuper(url.toString(), base);\n\t\t// Fix Safari bug with extending native classes\n\t\tObject.setPrototypeOf(this, Location.prototype);\n\t}\n\n\t/**\n\t * The full local path including query params.\n\t */\n\tget url(): string {\n\t\treturn this.pathname + this.search;\n\t}\n\n\t/**\n\t * Instantiate a Location from an element's href attribute\n\t * @param el\n\t * @returns new Location instance\n\t */\n\tstatic fromElement(el: Element): Location {\n\t\tconst href = el.getAttribute('href') || el.getAttribute('xlink:href') || '';\n\t\treturn new Location(href);\n\t}\n\n\t/**\n\t * Instantiate a Location from a URL object or string\n\t * @param url\n\t * @returns new Location instance\n\t */\n\tstatic fromUrl(url: URL | string): Location {\n\t\treturn new Location(url);\n\t}\n}\n", "import { match } from 'path-to-regexp';\n\nimport type { Path, MatchFunction } from 'path-to-regexp';\n\nexport { type Path };\n\ntype Params = Parameters<typeof match>;\n\n/** Create a match function from a path pattern that checks if a URLs matches it. */\nexport const matchPath = <P extends object = object>(\n\tpath: Params[0],\n\toptions?: Params[1]\n): MatchFunction<P> => {\n\tif (Array.isArray(path) && !path.length) {\n\t\tpath = '';\n\t}\n\n\ttry {\n\t\treturn match<P>(path, options);\n\t} catch (error) {\n\t\tthrow new Error(`[swup] Error parsing path \"${String(path)}\":\\n${String(error)}`);\n\t}\n};\n", "import type Swup from '../Swup.js';\nimport { Location } from '../helpers.js';\nimport type { Visit } from './Visit.js';\n\n/** A page object as used by swup and its cache. */\nexport interface PageData {\n\t/** The URL of the page */\n\turl: string;\n\t/** The complete HTML response received from the server */\n\thtml: string;\n}\n\n/** Define how a page is fetched. */\nexport interface FetchOptions extends Omit<RequestInit, 'cache'> {\n\t/** The request method. */\n\tmethod?: 'GET' | 'POST';\n\t/** The body of the request: raw string, form data object or URL params. */\n\tbody?: string | FormData | URLSearchParams;\n\t/** The request timeout in milliseconds. */\n\ttimeout?: number;\n\t/** Optional visit object with additional context. @internal */\n\tvisit?: Visit;\n}\n\nexport class FetchError extends Error {\n\turl: string;\n\tstatus?: number;\n\taborted: boolean;\n\ttimedOut: boolean;\n\tconstructor(\n\t\tmessage: string,\n\t\tdetails: { url: string; status?: number; aborted?: boolean; timedOut?: boolean }\n\t) {\n\t\tsuper(message);\n\t\tthis.name = 'FetchError';\n\t\tthis.url = details.url;\n\t\tthis.status = details.status;\n\t\tthis.aborted = details.aborted || false;\n\t\tthis.timedOut = details.timedOut || false;\n\t}\n}\n\n/**\n * Fetch a page from the server, return it and cache it.\n */\nexport async function fetchPage(\n\tthis: Swup,\n\turl: URL | string,\n\toptions: FetchOptions = {}\n): Promise<PageData> {\n\turl = Location.fromUrl(url).url;\n\n\tconst { visit = this.visit } = options;\n\tconst headers = { ...this.options.requestHeaders, ...options.headers };\n\tconst timeout = options.timeout ?? this.options.timeout;\n\tconst controller = new AbortController();\n\tconst { signal } = controller;\n\toptions = { ...options, headers, signal };\n\n\tlet timedOut = false;\n\tlet timeoutId: ReturnType<typeof setTimeout> | null = null;\n\tif (timeout && timeout > 0) {\n\t\ttimeoutId = setTimeout(() => {\n\t\t\ttimedOut = true;\n\t\t\tcontroller.abort('timeout');\n\t\t}, timeout);\n\t}\n\n\t// Allow hooking before this and returning a custom response-like object (e.g. custom fetch implementation)\n\tlet response: Response;\n\ttry {\n\t\tresponse = await this.hooks.call(\n\t\t\t'fetch:request',\n\t\t\tvisit,\n\t\t\t{ url, options },\n\t\t\t(visit, { url, options }) => fetch(url, options)\n\t\t);\n\t\tif (timeoutId) {\n\t\t\tclearTimeout(timeoutId);\n\t\t}\n\t} catch (error) {\n\t\tif (timedOut) {\n\t\t\tthis.hooks.call('fetch:timeout', visit, { url });\n\t\t\tthrow new FetchError(`Request timed out: ${url}`, { url, timedOut });\n\t\t}\n\t\tif ((error as Error)?.name === 'AbortError' || signal.aborted) {\n\t\t\tthrow new FetchError(`Request aborted: ${url}`, { url, aborted: true });\n\t\t}\n\t\tthrow error;\n\t}\n\n\tconst { status, url: responseUrl } = response;\n\tconst html = await response.text();\n\n\tif (status === 500) {\n\t\tthis.hooks.call('fetch:error', visit, { status, response, url: responseUrl });\n\t\tthrow new FetchError(`Server error: ${responseUrl}`, { status, url: responseUrl });\n\t}\n\n\tif (!html) {\n\t\tthrow new FetchError(`Empty response: ${responseUrl}`, { status, url: responseUrl });\n\t}\n\n\t// Resolve real url after potential redirect\n\tconst { url: finalUrl } = Location.fromUrl(responseUrl);\n\tconst page = { url: finalUrl, html };\n\n\t// Write to cache for safe methods and non-redirects\n\tif (visit.cache.write && (!options.method || options.method === 'GET') && url === finalUrl) {\n\t\tthis.cache.set(page.url, page);\n\t}\n\n\treturn page;\n}\n", "import type Swup from '../Swup.js';\nimport { Location } from '../helpers.js';\nimport { type PageData } from './fetchPage.js';\n\nexport interface CacheData extends PageData {}\n\n/**\n * In-memory page cache.\n */\nexport class Cache {\n\t/** Swup instance this cache belongs to */\n\tprotected swup: Swup;\n\n\t/** Cached pages, indexed by URL */\n\tprotected pages: Map<string, CacheData> = new Map();\n\n\tconstructor(swup: Swup) {\n\t\tthis.swup = swup;\n\t}\n\n\t/** Number of cached pages in memory. */\n\tget size(): number {\n\t\treturn this.pages.size;\n\t}\n\n\t/** All cached pages. */\n\tget all() {\n\t\tconst copy = new Map();\n\t\tthis.pages.forEach((page, key) => {\n\t\t\tcopy.set(key, { ...page });\n\t\t});\n\t\treturn copy;\n\t}\n\n\t/** Check if the given URL has been cached. */\n\thas(url: string): boolean {\n\t\treturn this.pages.has(this.resolve(url));\n\t}\n\n\t/** Return a shallow copy of the cached page object if available. */\n\tget(url: string): CacheData | undefined {\n\t\tconst result = this.pages.get(this.resolve(url));\n\t\tif (!result) return result;\n\t\treturn { ...result };\n\t}\n\n\t/** Create a cache record for the specified URL. */\n\tset(url: string, page: CacheData) {\n\t\turl = this.resolve(url);\n\t\tpage = { ...page, url };\n\t\tthis.pages.set(url, page);\n\t\tthis.swup.hooks.callSync('cache:set', undefined, { page });\n\t}\n\n\t/** Update a cache record, overwriting or adding custom data. */\n\tupdate(url: string, payload: object) {\n\t\turl = this.resolve(url);\n\t\tconst page = { ...this.get(url), ...payload, url } as CacheData;\n\t\tthis.pages.set(url, page);\n\t}\n\n\t/** Delete a cache record. */\n\tdelete(url: string): void {\n\t\tthis.pages.delete(this.resolve(url));\n\t}\n\n\t/** Empty the cache. */\n\tclear(): void {\n\t\tthis.pages.clear();\n\t\tthis.swup.hooks.callSync('cache:clear', undefined, undefined);\n\t}\n\n\t/** Remove all cache entries that return true for a given predicate function.  */\n\tprune(predicate: (url: string, page: CacheData) => boolean): void {\n\t\tthis.pages.forEach((page, url) => {\n\t\t\tif (predicate(url, page)) {\n\t\t\t\tthis.delete(url);\n\t\t\t}\n\t\t});\n\t}\n\n\t/** Resolve URLs by making them local and letting swup resolve them. */\n\tprotected resolve(urlToResolve: string): string {\n\t\tconst { url } = Location.fromUrl(urlToResolve);\n\t\treturn this.swup.resolveUrl(url);\n\t}\n}\n", "/** Find an element by selector. */\nexport const query = (selector: string, context: Document | Element = document) => {\n\treturn context.querySelector<HTMLElement>(selector);\n};\n\n/** Find a set of elements by selector. */\nexport const queryAll = (\n\tselector: string,\n\tcontext: Document | Element = document\n): HTMLElement[] => {\n\treturn Array.from(context.querySelectorAll(selector));\n};\n\n/** Return a Promise that resolves after the next event loop. */\nexport const nextTick = (): Promise<void> => {\n\treturn new Promise((resolve) => {\n\t\trequestAnimationFrame(() => {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t});\n};\n\n/** Check if an object is a Promise or a Thenable */\nexport function isPromise<T>(obj: unknown): obj is PromiseLike<T> {\n\treturn (\n\t\t!!obj &&\n\t\t(typeof obj === 'object' || typeof obj === 'function') &&\n\t\ttypeof (obj as Record<string, unknown>).then === 'function'\n\t);\n}\n\n/** Call a function as a Promise. Resolves with the returned Promsise or immediately. */\n// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any\nexport function runAsPromise(func: Function, args: unknown[] = []): Promise<unknown> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst result: unknown = func(...args);\n\t\tif (isPromise(result)) {\n\t\t\tresult.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(result);\n\t\t}\n\t});\n}\n\n/**\n * Force a layout reflow, e.g. after adding classnames\n * @see https://stackoverflow.com/a/21665117/3759615\n */\nexport function forceReflow(element?: HTMLElement): void {\n\telement = element || document.body;\n\telement?.getBoundingClientRect();\n}\n\n/**\n * Read data attribute from closest element with that attribute.\n *\n * Returns `undefined` if no element is found or attribute is missing.\n * Returns `true` if attribute is present without a value.\n */\nexport function getContextualAttr(\n\tel: Element | undefined,\n\tattr: string\n): string | boolean | undefined {\n\tconst target = el?.closest(`[${attr}]`);\n\treturn target?.hasAttribute(attr) ? target?.getAttribute(attr) || true : undefined;\n}\n", "import type Swup from '../Swup.js';\nimport { queryAll } from '../utils.js';\n\nexport class Classes {\n\tprotected swup: Swup;\n\tprotected swupClasses = [\n\t\t'to-',\n\t\t'is-changing',\n\t\t'is-rendering',\n\t\t'is-popstate',\n\t\t'is-animating',\n\t\t'is-leaving'\n\t];\n\n\tconstructor(swup: Swup) {\n\t\tthis.swup = swup;\n\t}\n\n\tprotected get selectors(): string[] {\n\t\tconst { scope } = this.swup.visit.animation;\n\t\tif (scope === 'containers') return this.swup.visit.containers;\n\t\tif (scope === 'html') return ['html'];\n\t\tif (Array.isArray(scope)) return scope;\n\t\treturn [];\n\t}\n\n\tprotected get selector(): string {\n\t\treturn this.selectors.join(',');\n\t}\n\n\tprotected get targets(): HTMLElement[] {\n\t\tif (!this.selector.trim()) return [];\n\t\treturn queryAll(this.selector);\n\t}\n\n\tadd(...classes: string[]): void {\n\t\tthis.targets.forEach((target) => target.classList.add(...classes));\n\t}\n\n\tremove(...classes: string[]): void {\n\t\tthis.targets.forEach((target) => target.classList.remove(...classes));\n\t}\n\n\tclear(): void {\n\t\tthis.targets.forEach((target) => {\n\t\t\tconst remove = target.className.split(' ').filter((c) => this.isSwupClass(c));\n\t\t\ttarget.classList.remove(...remove);\n\t\t});\n\t}\n\n\tprotected isSwupClass(className: string): boolean {\n\t\treturn this.swupClasses.some((c) => className.startsWith(c));\n\t}\n}\n", "import type Swup from '../Swup.js';\nimport type { Options } from '../Swup.js';\nimport type { HistoryAction, HistoryDirection } from './navigate.js';\n\n/** See below for the class Visit {} definition */\n// export interface Visit {}\n\nexport interface VisitFrom {\n\t/** The URL of the previous page */\n\turl: string;\n\t/** The hash of the previous page */\n\thash?: string;\n}\n\nexport interface VisitTo {\n\t/** The URL of the next page */\n\turl: string;\n\t/** The hash of the next page */\n\thash?: string;\n\t/** The HTML content of the next page */\n\thtml?: string;\n\t/** The parsed document of the next page, available during visit */\n\tdocument?: Document;\n}\n\nexport interface VisitAnimation {\n\t/** Whether this visit is animated. Default: `true` */\n\tanimate: boolean;\n\t/** Whether to wait for the next page to load before starting the animation. Default: `false` */\n\twait: boolean;\n\t/** Name of a custom animation to run. */\n\tname?: string;\n\t/** Whether this animation uses the native browser ViewTransition API. Default: `false` */\n\tnative: boolean;\n\t/** Elements on which to add animation classes. Default: `html` element */\n\tscope: 'html' | 'containers' | string[];\n\t/** Selector for detecting animation timing. Default: `[class*=\"transition-\"]` */\n\tselector: Options['animationSelector'];\n}\n\nexport interface VisitScroll {\n\t/** Whether to reset the scroll position after the visit. Default: `true` */\n\treset: boolean;\n\t/** Anchor element to scroll to on the next page. */\n\ttarget?: string | false;\n}\n\nexport interface VisitTrigger {\n\t/** DOM element that triggered this visit. */\n\tel?: Element;\n\t/** DOM event that triggered this visit. */\n\tevent?: Event;\n}\n\nexport interface VisitCache {\n\t/** Whether this visit will try to load the requested page from cache. */\n\tread: boolean;\n\t/** Whether this visit will save the loaded page in cache. */\n\twrite: boolean;\n}\n\nexport interface VisitHistory {\n\t/** History action to perform: `push` for creating a new history entry, `replace` for replacing the current entry. Default: `push` */\n\taction: HistoryAction;\n\t/** Whether this visit was triggered by a browser history navigation. */\n\tpopstate: boolean;\n\t/** The direction of travel in case of a browser history navigation: backward or forward. */\n\tdirection: HistoryDirection | undefined;\n}\n\nexport interface VisitInitOptions {\n\tto: string;\n\tfrom?: string;\n\thash?: string;\n\tel?: Element;\n\tevent?: Event;\n}\n\n/** @internal */\nexport const VisitState = {\n\tCREATED: 1,\n\tQUEUED: 2,\n\tSTARTED: 3,\n\tLEAVING: 4,\n\tLOADED: 5,\n\tENTERING: 6,\n\tCOMPLETED: 7,\n\tABORTED: 8,\n\tFAILED: 9\n} as const;\n\n/** @internal */\nexport type VisitState = (typeof VisitState)[keyof typeof VisitState];\n\n/** An object holding details about the current visit. */\nexport class Visit {\n\t/** A unique ID to identify this visit */\n\tid: number;\n\t/** The current state of this visit @internal */\n\tstate: VisitState;\n\t/** The previous page, about to leave */\n\tfrom: VisitFrom;\n\t/** The next page, about to enter */\n\tto: VisitTo;\n\t/** The content containers, about to be replaced */\n\tcontainers: Options['containers'];\n\t/** Information about animated page transitions */\n\tanimation: VisitAnimation;\n\t/** What triggered this visit */\n\ttrigger: VisitTrigger;\n\t/** Cache behavior for this visit */\n\tcache: VisitCache;\n\t/** Browser history behavior on this visit */\n\thistory: VisitHistory;\n\t/** Scroll behavior on this visit */\n\tscroll: VisitScroll;\n\t/** User-defined metadata */\n\tmeta: Record<string, unknown>;\n\n\tconstructor(swup: Swup, options: VisitInitOptions) {\n\t\tconst { to, from, hash, el, event } = options;\n\n\t\tthis.id = Math.random();\n\t\tthis.state = VisitState.CREATED;\n\t\tthis.from = { url: from ?? swup.location.url, hash: swup.location.hash };\n\t\tthis.to = { url: to, hash };\n\t\tthis.containers = swup.options.containers;\n\t\tthis.animation = {\n\t\t\tanimate: true,\n\t\t\twait: false,\n\t\t\tname: undefined,\n\t\t\tnative: swup.options.native,\n\t\t\tscope: swup.options.animationScope,\n\t\t\tselector: swup.options.animationSelector\n\t\t};\n\t\tthis.trigger = { el, event };\n\t\tthis.cache = {\n\t\t\tread: swup.options.cache,\n\t\t\twrite: swup.options.cache\n\t\t};\n\t\tthis.history = {\n\t\t\taction: 'push',\n\t\t\tpopstate: false,\n\t\t\tdirection: undefined\n\t\t};\n\t\tthis.scroll = {\n\t\t\treset: true,\n\t\t\ttarget: undefined\n\t\t};\n\t\tthis.meta = {};\n\t}\n\n\t/** @internal */\n\tadvance(state: VisitState) {\n\t\tif (this.state < state) {\n\t\t\tthis.state = state;\n\t\t}\n\t}\n\n\t/** @internal */\n\tabort() {\n\t\tthis.state = VisitState.ABORTED;\n\t}\n\n\t/** Is this visit done, i.e. completed, failed, or aborted? */\n\tget done(): boolean {\n\t\treturn this.state >= VisitState.COMPLETED;\n\t}\n}\n\n/** Create a new visit object. */\nexport function createVisit(this: Swup, options: VisitInitOptions): Visit {\n\treturn new Visit(this, options);\n}\n", "import type { DelegateEvent } from 'delegate-it';\n\nimport type Swup from '../Swup.js';\nimport { isPromise, runAsPromise } from '../utils.js';\nimport { Visit } from './Visit.js';\nimport type { FetchOptions, PageData } from './fetchPage.js';\n\nexport interface HookDefinitions {\n\t'animation:out:start': undefined;\n\t'animation:out:await': { skip: boolean };\n\t'animation:out:end': undefined;\n\t'animation:in:start': undefined;\n\t'animation:in:await': { skip: boolean };\n\t'animation:in:end': undefined;\n\t'animation:skip': undefined;\n\t'cache:clear': undefined;\n\t'cache:set': { page: PageData };\n\t'content:replace': { page: PageData };\n\t'content:scroll': undefined;\n\t'enable': undefined;\n\t'disable': undefined;\n\t'fetch:request': { url: string; options: FetchOptions };\n\t'fetch:error': { url: string; status: number; response: Response };\n\t'fetch:timeout': { url: string };\n\t'history:popstate': { event: PopStateEvent };\n\t'link:click': { el: HTMLAnchorElement; event: DelegateEvent<MouseEvent> };\n\t'link:self': undefined;\n\t'link:anchor': { hash: string };\n\t'link:newtab': { href: string };\n\t'page:load': { page?: PageData; cache?: boolean; options: FetchOptions };\n\t'page:view': { url: string; title: string };\n\t'scroll:top': { options: ScrollIntoViewOptions };\n\t'scroll:anchor': { hash: string; options: ScrollIntoViewOptions };\n\t'visit:start': undefined;\n\t'visit:transition': undefined;\n\t'visit:abort': undefined;\n\t'visit:end': undefined;\n}\n\nexport interface HookReturnValues {\n\t'content:scroll': Promise<boolean> | boolean;\n\t'fetch:request': Promise<Response>;\n\t'page:load': Promise<PageData>;\n\t'scroll:top': boolean;\n\t'scroll:anchor': boolean;\n}\n\nexport type HookArguments<T extends HookName> = HookDefinitions[T];\n\nexport type HookName = keyof HookDefinitions;\n\nexport type HookNameWithModifier = `${HookName}.${HookModifier}`;\n\ntype HookModifier = 'once' | 'before' | 'replace';\n\n/** A generic hook handler. */\nexport type HookHandler<T extends HookName> = (\n\t/** Context about the current visit. */\n\tvisit: Visit,\n\t/** Local arguments passed into the handler. */\n\targs: HookArguments<T>\n) => Promise<unknown> | unknown;\n\n/** A default hook handler with an expected return type. */\nexport type HookDefaultHandler<T extends HookName> = (\n\t/** Context about the current visit. */\n\tvisit: Visit,\n\t/** Local arguments passed into the handler. */\n\targs: HookArguments<T>,\n\t/** Default handler to be executed. Available if replacing an internal hook handler. */\n\tdefaultHandler?: HookDefaultHandler<T>\n) => T extends keyof HookReturnValues ? HookReturnValues[T] : Promise<unknown> | unknown;\n\nexport type Handlers = {\n\t[K in HookName]: HookHandler<K>[];\n};\n\nexport type HookInitOptions = {\n\t[K in HookName as K | `${K}.${HookModifier}`]: HookHandler<K>;\n} & {\n\t[K in HookName as K | `${K}.${HookModifier}.${HookModifier}`]: HookHandler<K>;\n};\n\n/** Unregister a previously registered hook handler. */\nexport type HookUnregister = () => void;\n\n/** Define when and how a hook handler is executed. */\nexport type HookOptions = {\n\t/** Execute the hook once, then remove the handler */\n\tonce?: boolean;\n\t/** Execute the hook before the internal default handler */\n\tbefore?: boolean;\n\t/** Set a priority for when to execute this hook. Lower numbers execute first. Default: `0` */\n\tpriority?: number;\n\t/** Replace the internal default handler with this hook handler */\n\treplace?: boolean;\n};\n\nexport type HookRegistration<\n\tT extends HookName,\n\tH extends HookHandler<T> | HookDefaultHandler<T> = HookHandler<T>\n> = {\n\tid: number;\n\thook: T;\n\thandler: H;\n\tdefaultHandler?: HookDefaultHandler<T>;\n} & HookOptions;\n\ntype HookEventDetail = {\n\thook: HookName;\n\targs: unknown;\n\tvisit: Visit;\n};\n\nexport type HookEvent = CustomEvent<HookEventDetail>;\n\ntype HookLedger<T extends HookName> = Map<HookHandler<T>, HookRegistration<T>>;\n\ninterface HookRegistry extends Map<HookName, HookLedger<HookName>> {\n\tget<K extends HookName>(key: K): HookLedger<K> | undefined;\n\tset<K extends HookName>(key: K, value: HookLedger<K>): this;\n}\n\n/**\n * Hook registry.\n *\n * Create, trigger and handle hooks.\n *\n */\nexport class Hooks {\n\t/** Swup instance this registry belongs to */\n\tprotected swup: Swup;\n\n\t/** Map of all registered hook handlers. */\n\tprotected registry: HookRegistry = new Map();\n\n\t// Can we deduplicate this somehow? Or make it error when not in sync with HookDefinitions?\n\t// https://stackoverflow.com/questions/53387838/how-to-ensure-an-arrays-values-the-keys-of-a-typescript-interface/53395649\n\tprotected readonly hooks: HookName[] = [\n\t\t'animation:out:start',\n\t\t'animation:out:await',\n\t\t'animation:out:end',\n\t\t'animation:in:start',\n\t\t'animation:in:await',\n\t\t'animation:in:end',\n\t\t'animation:skip',\n\t\t'cache:clear',\n\t\t'cache:set',\n\t\t'content:replace',\n\t\t'content:scroll',\n\t\t'enable',\n\t\t'disable',\n\t\t'fetch:request',\n\t\t'fetch:error',\n\t\t'fetch:timeout',\n\t\t'history:popstate',\n\t\t'link:click',\n\t\t'link:self',\n\t\t'link:anchor',\n\t\t'link:newtab',\n\t\t'page:load',\n\t\t'page:view',\n\t\t'scroll:top',\n\t\t'scroll:anchor',\n\t\t'visit:start',\n\t\t'visit:transition',\n\t\t'visit:abort',\n\t\t'visit:end'\n\t];\n\n\tconstructor(swup: Swup) {\n\t\tthis.swup = swup;\n\t\tthis.init();\n\t}\n\n\t/**\n\t * Create ledgers for all core hooks.\n\t */\n\tprotected init() {\n\t\tthis.hooks.forEach((hook) => this.create(hook));\n\t}\n\n\t/**\n\t * Create a new hook type.\n\t */\n\tcreate(hook: string) {\n\t\tif (!this.registry.has(hook as HookName)) {\n\t\t\tthis.registry.set(hook as HookName, new Map());\n\t\t}\n\t}\n\n\t/**\n\t * Check if a hook type exists.\n\t */\n\texists(hook: HookName): boolean {\n\t\treturn this.registry.has(hook);\n\t}\n\n\t/**\n\t * Get the ledger with all registrations for a hook.\n\t */\n\tprotected get<T extends HookName>(hook: T): HookLedger<T> | undefined {\n\t\tconst ledger = this.registry.get(hook);\n\t\tif (ledger) {\n\t\t\treturn ledger;\n\t\t}\n\t\tconsole.error(`Unknown hook '${hook}'`);\n\t}\n\n\t/**\n\t * Remove all handlers of all hooks.\n\t */\n\tclear() {\n\t\tthis.registry.forEach((ledger) => ledger.clear());\n\t}\n\n\t/**\n\t * Register a new hook handler.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute\n\t * @param options Object to specify how and when the handler is executed\n\t *                Available options:\n\t *                - `once`: Only execute the handler once\n\t *                - `before`: Execute the handler before the default handler\n\t *                - `priority`: Specify the order in which the handlers are executed\n\t *                - `replace`: Replace the default handler with this handler\n\t * @returns A function to unregister the handler\n\t */\n\n\t// Overload: replacing default handler\n\ton<T extends HookName, O extends HookOptions>(hook: T, handler: HookDefaultHandler<T>, options: O & { replace: true }): HookUnregister; // prettier-ignore\n\t// Overload: passed in handler options\n\ton<T extends HookName, O extends HookOptions>(hook: T, handler: HookHandler<T>, options: O): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\ton<T extends HookName>(hook: T, handler: HookHandler<T>): HookUnregister; // prettier-ignore\n\t// Implementation\n\ton<T extends HookName, O extends HookOptions>(\n\t\thook: T,\n\t\thandler: O['replace'] extends true ? HookDefaultHandler<T> : HookHandler<T>,\n\t\toptions: Partial<O> = {}\n\t): HookUnregister {\n\t\tconst ledger = this.get(hook);\n\t\tif (!ledger) {\n\t\t\tconsole.warn(`Hook '${hook}' not found.`);\n\t\t\treturn () => {};\n\t\t}\n\n\t\tconst id = ledger.size + 1;\n\t\tconst registration: HookRegistration<T> = { ...options, id, hook, handler };\n\t\tledger.set(handler, registration);\n\n\t\treturn () => this.off(hook, handler);\n\t}\n\n\t/**\n\t * Register a new hook handler to run before the default handler.\n\t * Shortcut for `hooks.on(hook, handler, { before: true })`.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute\n\t * @param options Any other event options (see `hooks.on()` for details)\n\t * @returns A function to unregister the handler\n\t * @see on\n\t */\n\t// Overload: passed in handler options\n\tbefore<T extends HookName>(hook: T, handler: HookHandler<T>, options: HookOptions): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\tbefore<T extends HookName>(hook: T, handler: HookHandler<T>): HookUnregister;\n\t// Implementation\n\tbefore<T extends HookName>(\n\t\thook: T,\n\t\thandler: HookHandler<T>,\n\t\toptions: HookOptions = {}\n\t): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, before: true });\n\t}\n\n\t/**\n\t * Register a new hook handler to replace the default handler.\n\t * Shortcut for `hooks.on(hook, handler, { replace: true })`.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute instead of the default handler\n\t * @param options Any other event options (see `hooks.on()` for details)\n\t * @returns A function to unregister the handler\n\t * @see on\n\t */\n\t// Overload: passed in handler options\n\treplace<T extends HookName>(hook: T, handler: HookDefaultHandler<T>, options: HookOptions): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\treplace<T extends HookName>(hook: T, handler: HookDefaultHandler<T>): HookUnregister; // prettier-ignore\n\t// Implementation\n\treplace<T extends HookName>(\n\t\thook: T,\n\t\thandler: HookDefaultHandler<T>,\n\t\toptions: HookOptions = {}\n\t): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, replace: true });\n\t}\n\n\t/**\n\t * Register a new hook handler to run once.\n\t * Shortcut for `hooks.on(hook, handler, { once: true })`.\n\t * @param hook Name of the hook to listen for\n\t * @param handler The handler function to execute\n\t * @param options Any other event options (see `hooks.on()` for details)\n\t * @see on\n\t */\n\t// Overload: passed in handler options\n\tonce<T extends HookName>(hook: T, handler: HookHandler<T>, options: HookOptions): HookUnregister; // prettier-ignore\n\t// Overload: no handler options\n\tonce<T extends HookName>(hook: T, handler: HookHandler<T>): HookUnregister;\n\t// Implementation\n\tonce<T extends HookName>(\n\t\thook: T,\n\t\thandler: HookHandler<T>,\n\t\toptions: HookOptions = {}\n\t): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, once: true });\n\t}\n\n\t/**\n\t * Unregister a hook handler.\n\t * @param hook Name of the hook the handler is registered for\n\t * @param handler The handler function that was registered.\n\t *                If omitted, all handlers for the hook will be removed.\n\t */\n\t// Overload: unregister a specific handler\n\toff<T extends HookName>(hook: T, handler: HookHandler<T> | HookDefaultHandler<T>): void;\n\t// Overload: unregister all handlers\n\toff<T extends HookName>(hook: T): void;\n\t// Implementation\n\toff<T extends HookName>(hook: T, handler?: HookHandler<T> | HookDefaultHandler<T>): void {\n\t\tconst ledger = this.get(hook);\n\t\tif (ledger && handler) {\n\t\t\tconst deleted = ledger.delete(handler);\n\t\t\tif (!deleted) {\n\t\t\t\tconsole.warn(`Handler for hook '${hook}' not found.`);\n\t\t\t}\n\t\t} else if (ledger) {\n\t\t\tledger.clear();\n\t\t}\n\t}\n\n\t/**\n\t * Trigger a hook asynchronously, executing its default handler and all registered handlers.\n\t * Will execute all handlers in order and `await` any `Promise`s they return.\n\t * @param hook Name of the hook to trigger\n\t * @param visit The visit object this hook belongs to\n\t * @param args Arguments to pass to the handler\n\t * @param defaultHandler A default implementation of this hook to execute\n\t * @returns The resolved return value of the executed default handler\n\t */\n\t// Overload: default order of arguments\n\tasync call<T extends HookName>(hook: T, visit: Visit | undefined, args: HookArguments<T>, defaultHandler?: HookDefaultHandler<T>): Promise<Awaited<ReturnType<HookDefaultHandler<T>>>>; // prettier-ignore\n\t// Overload: legacy order of arguments, with visit missing\n\tasync call<T extends HookName>(hook: T, args: HookArguments<T>, defaultHandler?: HookDefaultHandler<T>): Promise<Awaited<ReturnType<HookDefaultHandler<T>>>>; // prettier-ignore\n\t// Implementation\n\tasync call<T extends HookName>(\n\t\thook: T,\n\t\targ1: Visit | HookArguments<T>,\n\t\targ2: HookArguments<T> | HookDefaultHandler<T>,\n\t\targ3?: HookDefaultHandler<T>\n\t): Promise<Awaited<ReturnType<HookDefaultHandler<T>>>> {\n\t\tconst [visit, args, defaultHandler] = this.parseCallArgs(hook, arg1, arg2, arg3);\n\n\t\tconst { before, handler, after } = this.getHandlers(hook, defaultHandler);\n\t\tawait this.run(before, visit, args);\n\t\tconst [result] = await this.run(handler, visit, args, true);\n\t\tawait this.run(after, visit, args);\n\t\tthis.dispatchDomEvent(hook, visit, args);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Trigger a hook synchronously, executing its default handler and all registered handlers.\n\t * Will execute all handlers in order, but will **not** `await` any `Promise`s they return.\n\t * @param hook Name of the hook to trigger\n\t * @param visit The visit object this hook belongs to\n\t * @param args Arguments to pass to the handler\n\t * @param defaultHandler A default implementation of this hook to execute\n\t * @returns The (possibly unresolved) return value of the executed default handler\n\t */\n\t// Overload: default order of arguments\n\tcallSync<T extends HookName>(hook: T, visit: Visit | undefined, args: HookArguments<T>, defaultHandler?: HookDefaultHandler<T>): ReturnType<HookDefaultHandler<T>>; // prettier-ignore\n\t// Overload: legacy order of arguments, with visit missing\n\tcallSync<T extends HookName>(hook: T, args: HookArguments<T>, defaultHandler?: HookDefaultHandler<T>): ReturnType<HookDefaultHandler<T>>; // prettier-ignore\n\t// Implementation\n\tcallSync<T extends HookName>(\n\t\thook: T,\n\t\targ1: Visit | HookArguments<T>,\n\t\targ2: HookArguments<T> | HookDefaultHandler<T>,\n\t\targ3?: HookDefaultHandler<T>\n\t): ReturnType<HookDefaultHandler<T>> {\n\t\tconst [visit, args, defaultHandler] = this.parseCallArgs(hook, arg1, arg2, arg3);\n\t\tconst { before, handler, after } = this.getHandlers(hook, defaultHandler);\n\t\tthis.runSync(before, visit, args);\n\t\tconst [result] = this.runSync(handler, visit, args, true);\n\t\tthis.runSync(after, visit, args);\n\t\tthis.dispatchDomEvent(hook, visit, args);\n\t\treturn result;\n\t}\n\n\t/**\n\t * Parse the call arguments for call() and callSync() to allow legacy argument order.\n\t */\n\tprotected parseCallArgs<T extends HookName>(\n\t\thook: T,\n\t\targ1: Visit | HookArguments<T> | undefined,\n\t\targ2: HookArguments<T> | HookDefaultHandler<T>,\n\t\targ3?: HookDefaultHandler<T>\n\t): [Visit | undefined, HookArguments<T>, HookDefaultHandler<T> | undefined] {\n\t\tconst isLegacyOrder =\n\t\t\t!(arg1 instanceof Visit) && (typeof arg1 === 'object' || typeof arg2 === 'function');\n\t\tif (isLegacyOrder) {\n\t\t\t// Legacy positioning: arguments in second or handler passed in third place\n\t\t\treturn [undefined, arg1 as HookArguments<T>, arg2 as HookDefaultHandler<T>];\n\t\t} else {\n\t\t\t// Default positioning: visit passed in as first argument\n\t\t\treturn [arg1, arg2 as HookArguments<T>, arg3];\n\t\t}\n\t}\n\n\t/**\n\t * Execute the handlers for a hook, in order, as `Promise`s that will be `await`ed.\n\t * @param registrations The registrations (handler + options) to execute\n\t * @param args Arguments to pass to the handler\n\t */\n\n\t// Overload: running HookDefaultHandler: expect HookDefaultHandler return type\n\tprotected async run<T extends HookName>(registrations: HookRegistration<T, HookDefaultHandler<T>>[], visit: Visit | undefined, args: HookArguments<T>, rethrow: true): Promise<Awaited<ReturnType<HookDefaultHandler<T>>>[]>; // prettier-ignore\n\t// Overload:  running user handler: expect no specific type\n\tprotected async run<T extends HookName>(registrations: HookRegistration<T>[], visit: Visit | undefined, args: HookArguments<T>): Promise<unknown[]>; // prettier-ignore\n\t// Implementation\n\tprotected async run<T extends HookName, R extends HookRegistration<T>[]>(\n\t\tregistrations: R,\n\t\tvisit: Visit | undefined = this.swup.visit,\n\t\targs: HookArguments<T>,\n\t\trethrow: boolean = false\n\t): Promise<Awaited<ReturnType<HookDefaultHandler<T>>> | unknown[]> {\n\t\tconst results = [];\n\t\tfor (const { hook, handler, defaultHandler, once } of registrations) {\n\t\t\tif (visit?.done) continue;\n\t\t\tif (once) this.off(hook, handler);\n\t\t\ttry {\n\t\t\t\tconst result = await runAsPromise(handler, [visit, args, defaultHandler]);\n\t\t\t\tresults.push(result);\n\t\t\t} catch (error) {\n\t\t\t\tif (rethrow) {\n\t\t\t\t\tthrow error;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(`Error in hook '${hook}':`, error);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * Execute the handlers for a hook, in order, without `await`ing any returned `Promise`s.\n\t * @param registrations The registrations (handler + options) to execute\n\t * @param args Arguments to pass to the handler\n\t */\n\n\t// Overload: running HookDefaultHandler: expect HookDefaultHandler return type\n\tprotected runSync<T extends HookName>(registrations: HookRegistration<T, HookDefaultHandler<T>>[], visit: Visit | undefined, args: HookArguments<T>, rethrow: true): ReturnType<HookDefaultHandler<T>>[]; // prettier-ignore\n\t// Overload: running user handler: expect no specific type\n\tprotected runSync<T extends HookName>(registrations: HookRegistration<T>[], visit: Visit | undefined, args: HookArguments<T>): unknown[]; // prettier-ignore\n\t// Implementation\n\tprotected runSync<T extends HookName, R extends HookRegistration<T>[]>(\n\t\tregistrations: R,\n\t\tvisit: Visit | undefined = this.swup.visit,\n\t\targs: HookArguments<T>,\n\t\trethrow: boolean = false\n\t): (ReturnType<HookDefaultHandler<T>> | unknown)[] {\n\t\tconst results = [];\n\t\tfor (const { hook, handler, defaultHandler, once } of registrations) {\n\t\t\tif (visit?.done) continue;\n\t\t\tif (once) this.off(hook, handler);\n\t\t\ttry {\n\t\t\t\tconst result = (handler as HookDefaultHandler<T>)(visit, args, defaultHandler);\n\t\t\t\tresults.push(result);\n\t\t\t\tif (isPromise(result)) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`Swup will not await Promises in handler for synchronous hook '${hook}'.`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (rethrow) {\n\t\t\t\t\tthrow error;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(`Error in hook '${hook}':`, error);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * Get all registered handlers for a hook, sorted by priority and registration order.\n\t * @param hook Name of the hook\n\t * @param defaultHandler The optional default handler of this hook\n\t * @returns An object with the handlers sorted into `before` and `after` arrays,\n\t *          as well as a flag indicating if the original handler was replaced\n\t */\n\tprotected getHandlers<T extends HookName>(hook: T, defaultHandler?: HookDefaultHandler<T>) {\n\t\tconst ledger = this.get(hook);\n\t\tif (!ledger) {\n\t\t\treturn { found: false, before: [], handler: [], after: [], replaced: false };\n\t\t}\n\n\t\tconst registrations = Array.from(ledger.values());\n\n\t\t// Let TypeScript know that replaced handlers are default handlers by filtering to true\n\t\tconst def = (T: HookRegistration<T>): T is HookRegistration<T, HookDefaultHandler<T>> => true; // prettier-ignore\n\t\tconst sort = this.sortRegistrations;\n\n\t\t// Filter into before, after, and replace handlers\n\t\tconst before = registrations.filter(({ before, replace }) => before && !replace).sort(sort);\n\t\tconst replace = registrations.filter(({ replace }) => replace).filter(def).sort(sort); // prettier-ignore\n\t\tconst after = registrations.filter(({ before, replace }) => !before && !replace).sort(sort);\n\t\tconst replaced = replace.length > 0;\n\n\t\t// Define main handler registration\n\t\t// Created as HookRegistration[] array to allow passing it into hooks.run() directly\n\t\tlet handler: HookRegistration<T, HookDefaultHandler<T>>[] = [];\n\t\tif (defaultHandler) {\n\t\t\thandler = [{ id: 0, hook, handler: defaultHandler }];\n\t\t\tif (replaced) {\n\t\t\t\tconst index = replace.length - 1;\n\t\t\t\tconst { handler: replacingHandler, once } = replace[index];\n\t\t\t\tconst createDefaultHandler = (index: number): HookDefaultHandler<T> | undefined => {\n\t\t\t\t\tconst next = replace[index - 1];\n\t\t\t\t\tif (next) {\n\t\t\t\t\t\treturn (visit, args) =>\n\t\t\t\t\t\t\tnext.handler(visit, args, createDefaultHandler(index - 1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn defaultHandler;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tconst nestedDefaultHandler = createDefaultHandler(index);\n\t\t\t\thandler = [{ id: 0, hook, once, handler: replacingHandler, defaultHandler: nestedDefaultHandler }]; // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\treturn { found: true, before, handler, after, replaced };\n\t}\n\n\t/**\n\t * Sort two hook registrations by priority and registration order.\n\t * @param a The registration object to compare\n\t * @param b The other registration object to compare with\n\t * @returns The sort direction\n\t */\n\tprotected sortRegistrations<T extends HookName>(\n\t\ta: HookRegistration<T>,\n\t\tb: HookRegistration<T>\n\t): number {\n\t\tconst priority = (a.priority ?? 0) - (b.priority ?? 0);\n\t\tconst id = a.id - b.id;\n\t\treturn priority || id || 0;\n\t}\n\n\t/**\n\t * Dispatch a custom event on the `document` for a hook. Prefixed with `swup:`\n\t * @param hook Name of the hook.\n\t */\n\tprotected dispatchDomEvent<T extends HookName>(\n\t\thook: T,\n\t\tvisit: Visit | undefined,\n\t\targs?: HookArguments<T>\n\t): void {\n\t\tif (visit?.done) return;\n\n\t\tconst detail: HookEventDetail = { hook, args, visit: visit || this.swup.visit };\n\t\tdocument.dispatchEvent(\n\t\t\tnew CustomEvent<HookEventDetail>(`swup:any`, { detail, bubbles: true })\n\t\t);\n\t\tdocument.dispatchEvent(\n\t\t\tnew CustomEvent<HookEventDetail>(`swup:${hook}`, { detail, bubbles: true })\n\t\t);\n\t}\n\n\t/**\n\t * Parse a hook name into the name and any modifiers.\n\t * @param hook Name of the hook.\n\t */\n\tparseName(hook: HookName | HookNameWithModifier): [HookName, Partial<HookOptions>] {\n\t\tconst [name, ...modifiers] = hook.split('.');\n\t\tconst options = modifiers.reduce((acc, mod) => ({ ...acc, [mod]: true }), {});\n\t\treturn [name as HookName, options];\n\t}\n}\n", "import { query } from '../utils.js';\n\n/**\n * Find the anchor element for a given hash.\n *\n * @param hash Hash with or without leading '#'\n * @returns The element, if found, or null.\n *\n * @see https://html.spec.whatwg.org/#find-a-potential-indicated-element\n */\nexport const getAnchorElement = (hash?: string): Element | null => {\n\tif (hash && hash.charAt(0) === '#') {\n\t\thash = hash.substring(1);\n\t}\n\n\tif (!hash) {\n\t\treturn null;\n\t}\n\n\tconst decoded = decodeURIComponent(hash);\n\tlet element =\n\t\tdocument.getElementById(hash) ||\n\t\tdocument.getElementById(decoded) ||\n\t\tquery(`a[name='${CSS.escape(hash)}']`) ||\n\t\tquery(`a[name='${CSS.escape(decoded)}']`);\n\n\tif (!element && hash === 'top') {\n\t\telement = document.body;\n\t}\n\n\treturn element;\n};\n", "import { queryAll } from '../utils.js';\nimport type Swup from '../Swup.js';\nimport type { Options } from '../Swup.js';\n\nconst TRANSITION = 'transition';\nconst ANIMATION = 'animation';\n\ntype AnimationType = typeof TRANSITION | typeof ANIMATION;\ntype AnimationEndEvent = `${AnimationType}end`;\ntype AnimationProperty = 'Delay' | 'Duration';\ntype AnimationStyleKey = `${AnimationType}${AnimationProperty}` | 'transitionProperty';\n\nexport type AnimationDirection = 'in' | 'out';\n\n/**\n * Return a Promise that resolves when all CSS animations and transitions\n * are done on the page. Filters by selector or takes elements directly.\n */\nexport async function awaitAnimations(\n\tthis: Swup,\n\t{\n\t\tselector,\n\t\telements\n\t}: {\n\t\tselector: Options['animationSelector'];\n\t\telements?: NodeListOf<HTMLElement> | HTMLElement[];\n\t}\n): Promise<void> {\n\t// Allow usage of swup without animations: { animationSelector: false }\n\tif (selector === false && !elements) {\n\t\treturn;\n\t}\n\n\t// Allow passing in elements\n\tlet animatedElements: HTMLElement[] = [];\n\tif (elements) {\n\t\tanimatedElements = Array.from(elements);\n\t} else if (selector) {\n\t\tanimatedElements = queryAll(selector, document.body);\n\t\t// Warn if no elements match the selector, but keep things going\n\t\tif (!animatedElements.length) {\n\t\t\tconsole.warn(`[swup] No elements found matching animationSelector \\`${selector}\\``);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tconst awaitedAnimations = animatedElements.map((el) => awaitAnimationsOnElement(el));\n\tconst hasAnimations = awaitedAnimations.filter(Boolean).length > 0;\n\tif (!hasAnimations) {\n\t\tif (selector) {\n\t\t\tconsole.warn(\n\t\t\t\t`[swup] No CSS animation duration defined on elements matching \\`${selector}\\``\n\t\t\t);\n\t\t}\n\t\treturn;\n\t}\n\n\tawait Promise.all(awaitedAnimations);\n}\n\nfunction awaitAnimationsOnElement(element: HTMLElement): Promise<void> | false {\n\tconst { type, timeout, propCount } = getTransitionInfo(element);\n\n\t// Resolve immediately if no transition defined\n\tif (!type || !timeout) {\n\t\treturn false;\n\t}\n\n\treturn new Promise((resolve) => {\n\t\tconst endEvent: AnimationEndEvent = `${type}end`;\n\t\tconst startTime = performance.now();\n\t\tlet propsTransitioned = 0;\n\n\t\tconst end = () => {\n\t\t\telement.removeEventListener(endEvent, onEnd);\n\t\t\tresolve();\n\t\t};\n\n\t\tconst onEnd = (event: TransitionEvent | AnimationEvent) => {\n\t\t\t// Skip transitions on child elements\n\t\t\tif (event.target !== element) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Skip transitions that happened before we started listening\n\t\t\tconst elapsedTime = (performance.now() - startTime) / 1000;\n\t\t\tif (elapsedTime < event.elapsedTime) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// End if all properties have transitioned\n\t\t\tif (++propsTransitioned >= propCount) {\n\t\t\t\tend();\n\t\t\t}\n\t\t};\n\n\t\tsetTimeout(() => {\n\t\t\tif (propsTransitioned < propCount) {\n\t\t\t\tend();\n\t\t\t}\n\t\t}, timeout + 1);\n\n\t\telement.addEventListener(endEvent, onEnd);\n\t});\n}\n\nfunction getTransitionInfo(element: Element) {\n\tconst styles = window.getComputedStyle(element);\n\n\tconst transitionDelays = getStyleProperties(styles, `${TRANSITION}Delay`);\n\tconst transitionDurations = getStyleProperties(styles, `${TRANSITION}Duration`);\n\tconst transitionTimeout = calculateTimeout(transitionDelays, transitionDurations);\n\n\tconst animationDelays = getStyleProperties(styles, `${ANIMATION}Delay`);\n\tconst animationDurations = getStyleProperties(styles, `${ANIMATION}Duration`);\n\tconst animationTimeout = calculateTimeout(animationDelays, animationDurations);\n\n\tconst timeout = Math.max(transitionTimeout, animationTimeout);\n\tconst type: AnimationType | null =\n\t\ttimeout > 0 ? (transitionTimeout > animationTimeout ? TRANSITION : ANIMATION) : null;\n\tconst propCount = type\n\t\t? type === TRANSITION\n\t\t\t? transitionDurations.length\n\t\t\t: animationDurations.length\n\t\t: 0;\n\n\treturn {\n\t\ttype,\n\t\ttimeout,\n\t\tpropCount\n\t};\n}\n\nexport function getStyleProperties(styles: CSSStyleDeclaration, key: AnimationStyleKey): string[] {\n\treturn (styles[key] || '').split(', ');\n}\n\nexport function calculateTimeout(delays: string[], durations: string[]): number {\n\twhile (delays.length < durations.length) {\n\t\tdelays = delays.concat(delays);\n\t}\n\n\treturn Math.max(...durations.map((duration, i) => toMs(duration) + toMs(delays[i])));\n}\n\nexport function toMs(time: string): number {\n\treturn parseFloat(time) * 1000;\n}\n", "import type Swup from '../Swup.js';\nimport { FetchError, type FetchOptions, type PageData } from './fetchPage.js';\nimport { type VisitInitOptions, type Visit, VisitState } from './Visit.js';\nimport { createHistoryRecord, updateHistoryRecord, Location, classify } from '../helpers.js';\nimport { getContextualAttr } from '../utils.js';\n\nexport type HistoryAction = 'push' | 'replace';\nexport type HistoryDirection = 'forwards' | 'backwards';\nexport type NavigationToSelfAction = 'scroll' | 'navigate';\nexport type CacheControl = Partial<{ read: boolean; write: boolean }>;\n\n/** Define how to navigate to a page. */\ntype NavigationOptions = {\n\t/** Whether this visit is animated. Default: `true` */\n\tanimate?: boolean;\n\t/** Name of a custom animation to run. */\n\tanimation?: string;\n\t/** History action to perform: `push` for creating a new history entry, `replace` for replacing the current entry. Default: `push` */\n\thistory?: HistoryAction;\n\t/** Whether this visit should read from or write to the cache. */\n\tcache?: CacheControl;\n\t/** Custom metadata associated with this visit. */\n\tmeta?: Record<string, unknown>;\n};\n\n/**\n * Navigate to a new URL.\n * @param url The URL to navigate to.\n * @param options Options for how to perform this visit.\n * @returns Promise<void>\n */\nexport function navigate(\n\tthis: Swup,\n\turl: string,\n\toptions: NavigationOptions & FetchOptions = {},\n\tinit: Omit<VisitInitOptions, 'to'> = {}\n) {\n\tif (typeof url !== 'string') {\n\t\tthrow new Error(`swup.navigate() requires a URL parameter`);\n\t}\n\n\t// Check if the visit should be ignored\n\tif (this.shouldIgnoreVisit(url, { el: init.el, event: init.event })) {\n\t\twindow.location.assign(url);\n\t\treturn;\n\t}\n\n\tconst { url: to, hash } = Location.fromUrl(url);\n\n\tconst visit = this.createVisit({ ...init, to, hash });\n\tthis.performNavigation(visit, options);\n}\n\n/**\n * Start a visit to a new URL.\n *\n * Internal method that assumes the visit context has already been created.\n *\n * As a user, you should call `swup.navigate(url)` instead.\n *\n * @param url The URL to navigate to.\n * @param options Options for how to perform this visit.\n * @returns Promise<void>\n */\nexport async function performNavigation(\n\tthis: Swup,\n\tvisit: Visit,\n\toptions: NavigationOptions & FetchOptions = {}\n): Promise<void> {\n\tif (this.navigating) {\n\t\tif (this.visit.state >= VisitState.ENTERING) {\n\t\t\t// Currently navigating and content already loaded? Finish and queue\n\t\t\tvisit.state = VisitState.QUEUED;\n\t\t\tthis.onVisitEnd = () => this.performNavigation(visit, options);\n\t\t\treturn;\n\t\t} else {\n\t\t\t// Currently navigating and content not loaded? Abort running visit\n\t\t\tawait this.hooks.call('visit:abort', this.visit, undefined);\n\t\t\tdelete this.visit.to.document;\n\t\t\tthis.visit.state = VisitState.ABORTED;\n\t\t}\n\t}\n\n\tthis.navigating = true;\n\tthis.visit = visit;\n\n\tconst { el } = visit.trigger;\n\toptions.referrer = options.referrer || this.location.url;\n\n\tif (options.animate === false) {\n\t\tvisit.animation.animate = false;\n\t}\n\n\t// Clean up old animation classes\n\tif (!visit.animation.animate) {\n\t\tthis.classes.clear();\n\t}\n\n\t// Get history action from option or attribute on trigger element\n\tconst history = options.history || getContextualAttr(el, 'data-swup-history');\n\tif (typeof history === 'string' && ['push', 'replace'].includes(history)) {\n\t\tvisit.history.action = history as HistoryAction;\n\t}\n\n\t// Get custom animation name from option or attribute on trigger element\n\tconst animation = options.animation || getContextualAttr(el, 'data-swup-animation');\n\tif (typeof animation === 'string') {\n\t\tvisit.animation.name = animation;\n\t}\n\n\t// Get custom metadata from option\n\tvisit.meta = options.meta || {};\n\n\t// Sanitize cache option\n\tif (typeof options.cache === 'object') {\n\t\tvisit.cache.read = options.cache.read ?? visit.cache.read;\n\t\tvisit.cache.write = options.cache.write ?? visit.cache.write;\n\t} else if (options.cache !== undefined) {\n\t\tvisit.cache = { read: !!options.cache, write: !!options.cache };\n\t}\n\t// Delete this so that window.fetch doesn't mis-interpret it\n\tdelete options.cache;\n\n\ttry {\n\t\tawait this.hooks.call('visit:start', visit, undefined);\n\n\t\tvisit.state = VisitState.STARTED;\n\n\t\t// Begin loading page\n\t\tconst page = this.hooks.call('page:load', visit, { options }, async (visit, args) => {\n\t\t\t// Read from cache\n\t\t\tlet cachedPage: PageData | undefined;\n\t\t\tif (visit.cache.read) {\n\t\t\t\tcachedPage = this.cache.get(visit.to.url);\n\t\t\t}\n\n\t\t\targs.page = cachedPage || (await this.fetchPage(visit.to.url, args.options));\n\t\t\targs.cache = !!cachedPage;\n\n\t\t\treturn args.page;\n\t\t});\n\n\t\t/**\n\t\t * When the page is loaded: mark the visit as loaded and save\n\t\t * the raw html and a parsed document of the received page in the visit object\n\t\t */\n\t\tpage.then(({ html }) => {\n\t\t\tvisit.advance(VisitState.LOADED);\n\t\t\tvisit.to.html = html;\n\t\t\tvisit.to.document = new DOMParser().parseFromString(html, 'text/html');\n\t\t});\n\n\t\t// Create/update history record if this is not a popstate call or leads to the same URL\n\t\tconst newUrl = visit.to.url + visit.to.hash;\n\t\tif (!visit.history.popstate) {\n\t\t\tif (visit.history.action === 'replace' || visit.to.url === this.location.url) {\n\t\t\t\tupdateHistoryRecord(newUrl);\n\t\t\t} else {\n\t\t\t\tthis.currentHistoryIndex++;\n\t\t\t\tcreateHistoryRecord(newUrl, { index: this.currentHistoryIndex });\n\t\t\t}\n\t\t}\n\t\tthis.location = Location.fromUrl(newUrl);\n\n\t\t// Mark visit type with classes\n\t\tif (visit.history.popstate) {\n\t\t\tthis.classes.add('is-popstate');\n\t\t}\n\t\tif (visit.animation.name) {\n\t\t\tthis.classes.add(`to-${classify(visit.animation.name)}`);\n\t\t}\n\n\t\t// Wait for page before starting to animate out?\n\t\tif (visit.animation.wait) {\n\t\t\tawait page;\n\t\t}\n\n\t\t// Check if failed/aborted in the meantime\n\t\tif (visit.done) return;\n\n\t\t// Perform the actual transition: animate and replace content\n\t\tawait this.hooks.call('visit:transition', visit, undefined, async () => {\n\t\t\t// No animation? Just await page and render\n\t\t\tif (!visit.animation.animate) {\n\t\t\t\tawait this.hooks.call('animation:skip', undefined);\n\t\t\t\tawait this.renderPage(visit, await page);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Animate page out, render page, animate page in\n\t\t\tvisit.advance(VisitState.LEAVING);\n\t\t\tawait this.animatePageOut(visit);\n\t\t\tif (visit.animation.native && document.startViewTransition) {\n\t\t\t\tawait document.startViewTransition(\n\t\t\t\t\tasync () => await this.renderPage(visit, await page)\n\t\t\t\t).finished;\n\t\t\t} else {\n\t\t\t\tawait this.renderPage(visit, await page);\n\t\t\t}\n\t\t\tawait this.animatePageIn(visit);\n\t\t});\n\n\t\t// Check if failed/aborted in the meantime\n\t\tif (visit.done) return;\n\n\t\t// Finalize visit\n\t\tawait this.hooks.call('visit:end', visit, undefined, () => this.classes.clear());\n\t\tvisit.state = VisitState.COMPLETED;\n\t\tthis.navigating = false;\n\n\t\t/** Run eventually queued function */\n\t\tif (this.onVisitEnd) {\n\t\t\tthis.onVisitEnd();\n\t\t\tthis.onVisitEnd = undefined;\n\t\t}\n\t} catch (error) {\n\t\t// Return early if error is undefined or signals an aborted request\n\t\tif (!error || (error as FetchError)?.aborted) {\n\t\t\tvisit.state = VisitState.ABORTED;\n\t\t\treturn;\n\t\t}\n\n\t\tvisit.state = VisitState.FAILED;\n\n\t\t// Log to console\n\t\tconsole.error(error);\n\n\t\t// Remove current history entry, then load requested url in browser\n\t\tthis.options.skipPopStateHandling = () => {\n\t\t\twindow.location.assign(visit.to.url + visit.to.hash);\n\t\t\treturn true;\n\t\t};\n\n\t\t// Go back to the actual page we're still at\n\t\twindow.history.back();\n\t} finally {\n\t\tdelete visit.to.document;\n\t}\n}\n", "import type Swup from '../Swup.js';\nimport type { Visit } from './Visit.js';\n\n/**\n * Perform the out/leave animation of the current page.\n * @returns Promise<void>\n */\nexport const animatePageOut = async function (this: Swup, visit: Visit) {\n\tawait this.hooks.call('animation:out:start', visit, undefined, () => {\n\t\tthis.classes.add('is-changing', 'is-animating', 'is-leaving');\n\t});\n\n\tawait this.hooks.call('animation:out:await', visit, { skip: false }, (visit, { skip }) => {\n\t\tif (skip) return;\n\t\treturn this.awaitAnimations({ selector: visit.animation.selector });\n\t});\n\n\tawait this.hooks.call('animation:out:end', visit, undefined);\n};\n", "import type Swup from '../Swup.js';\nimport { query, queryAll } from '../utils.js';\nimport type { Visit } from './Visit.js';\n\n/**\n * Perform the replacement of content after loading a page.\n *\n * @returns Whether all containers were replaced.\n */\nexport const replaceContent = function (this: Swup, visit: Visit): boolean {\n\tconst incomingDocument = visit.to.document;\n\tif (!incomingDocument) return false;\n\n\t// Update browser title\n\tconst title = incomingDocument.querySelector('title')?.innerText || '';\n\tdocument.title = title;\n\n\t// Save persisted elements\n\tconst persistedElements = queryAll('[data-swup-persist]:not([data-swup-persist=\"\"])');\n\n\t// Update content containers\n\tconst replaced = visit.containers\n\t\t.map((selector) => {\n\t\t\tconst currentEl = document.querySelector(selector);\n\t\t\tconst incomingEl = incomingDocument.querySelector(selector);\n\t\t\tif (currentEl && incomingEl) {\n\t\t\t\tcurrentEl.replaceWith(incomingEl.cloneNode(true));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!currentEl) {\n\t\t\t\tconsole.warn(`[swup] Container missing in current document: ${selector}`);\n\t\t\t}\n\t\t\tif (!incomingEl) {\n\t\t\t\tconsole.warn(`[swup] Container missing in incoming document: ${selector}`);\n\t\t\t}\n\t\t\treturn false;\n\t\t})\n\t\t.filter(Boolean);\n\n\t// Restore persisted elements\n\tpersistedElements.forEach((existing) => {\n\t\tconst key = existing.getAttribute('data-swup-persist');\n\t\tconst replacement = query(`[data-swup-persist=\"${key}\"]`);\n\t\tif (replacement && replacement !== existing) {\n\t\t\treplacement.replaceWith(existing);\n\t\t}\n\t});\n\n\t// Return true if all containers were replaced\n\treturn replaced.length === visit.containers.length;\n};\n", "import type Swup from '../Swup.js';\nimport type { Visit } from './Visit.js';\n\n/**\n * Update the scroll position after page render.\n * @returns Promise<boolean>\n */\nexport const scrollToContent = function (this: Swup, visit: Visit): boolean {\n\tconst options: ScrollIntoViewOptions = { behavior: 'auto' };\n\tconst { target, reset } = visit.scroll;\n\tconst scrollTarget = target ?? visit.to.hash;\n\n\tlet scrolled = false;\n\n\tif (scrollTarget) {\n\t\tscrolled = this.hooks.callSync(\n\t\t\t'scroll:anchor',\n\t\t\tvisit,\n\t\t\t{ hash: scrollTarget, options },\n\t\t\t(visit, { hash, options }) => {\n\t\t\t\tconst anchor = this.getAnchorElement(hash);\n\t\t\t\tif (anchor) {\n\t\t\t\t\tanchor.scrollIntoView(options);\n\t\t\t\t}\n\t\t\t\treturn !!anchor;\n\t\t\t}\n\t\t);\n\t}\n\n\tif (reset && !scrolled) {\n\t\tscrolled = this.hooks.callSync('scroll:top', visit, { options }, (visit, { options }) => {\n\t\t\twindow.scrollTo({ top: 0, left: 0, ...options });\n\t\t\treturn true;\n\t\t});\n\t}\n\n\treturn scrolled;\n};\n", "import type Swup from '../Swup.js';\nimport { nextTick } from '../utils.js';\nimport type { Visit } from './Visit.js';\n\n/**\n * Perform the in/enter animation of the next page.\n * @returns Promise<void>\n */\nexport const animatePageIn = async function (this: Swup, visit: Visit) {\n\t// Check if failed/aborted in the meantime\n\tif (visit.done) return;\n\n\tconst animation = this.hooks.call(\n\t\t'animation:in:await',\n\t\tvisit,\n\t\t{ skip: false },\n\t\t(visit, { skip }) => {\n\t\t\tif (skip) return;\n\t\t\treturn this.awaitAnimations({ selector: visit.animation.selector });\n\t\t}\n\t);\n\n\tawait nextTick();\n\n\tawait this.hooks.call('animation:in:start', visit, undefined, () => {\n\t\tthis.classes.remove('is-animating');\n\t});\n\n\tawait animation;\n\n\tawait this.hooks.call('animation:in:end', visit, undefined);\n};\n", "import { updateHistoryRecord, getCurrentUrl, classify, Location } from '../helpers.js';\nimport type Swup from '../Swup.js';\nimport type { PageData } from './fetchPage.js';\nimport { VisitState, type Visit } from './Visit.js';\n\n/**\n * Render the next page: replace the content and update scroll position.\n */\nexport const renderPage = async function (this: Swup, visit: Visit, page: PageData): Promise<void> {\n\t// Check if failed/aborted in the meantime\n\tif (visit.done) return;\n\n\tvisit.advance(VisitState.ENTERING);\n\n\tconst { url } = page;\n\n\t// update state if the url was redirected\n\tif (!this.isSameResolvedUrl(getCurrentUrl(), url)) {\n\t\tupdateHistoryRecord(url);\n\t\tthis.location = Location.fromUrl(url);\n\t\tvisit.to.url = this.location.url;\n\t\tvisit.to.hash = this.location.hash;\n\t}\n\n\t// replace content: allow handlers and plugins to overwrite paga data and containers\n\tawait this.hooks.call('content:replace', visit, { page }, (visit, { page }) => {\n\t\tthis.classes.remove('is-leaving');\n\t\t// only add for animated page loads\n\t\tif (visit.animation.animate) {\n\t\t\tthis.classes.add('is-rendering');\n\t\t}\n\t\tconst success = this.replaceContent(visit);\n\t\tif (!success) {\n\t\t\tthrow new Error('[swup] Container mismatch, aborting');\n\t\t}\n\t\tif (visit.animation.animate) {\n\t\t\t// Make sure to add these classes to new containers as well\n\t\t\tthis.classes.add('is-changing', 'is-animating', 'is-rendering');\n\t\t\tif (visit.animation.name) {\n\t\t\t\tthis.classes.add(`to-${classify(visit.animation.name)}`);\n\t\t\t}\n\t\t}\n\t});\n\n\t// scroll into view: either anchor or top of page\n\tawait this.hooks.call('content:scroll', visit, undefined, () => {\n\t\treturn this.scrollToContent(visit);\n\t});\n\n\tawait this.hooks.call('page:view', visit, { url: this.location.url, title: document.title });\n};\n", "import type Swup from '../Swup.js';\n\nexport type Plugin = {\n\t/** Identify as a swup plugin */\n\tisSwupPlugin: true;\n\t/** Name of this plugin */\n\tname: string;\n\t/** Version of this plugin. Currently not in use, defined here for backward compatiblity. */\n\tversion?: string;\n\t/** The swup instance that mounted this plugin */\n\tswup?: Swup;\n\t/** Version requirements of this plugin. Example: `{ swup: '>=4' }` */\n\trequires?: Record<string, string | string[]>;\n\t/** Run on mount */\n\tmount: () => void;\n\t/** Run on unmount */\n\tunmount: () => void;\n\t_beforeMount?: () => void;\n\t_afterUnmount?: () => void;\n\t_checkRequirements?: () => boolean;\n};\n\nconst isSwupPlugin = (maybeInvalidPlugin: unknown): maybeInvalidPlugin is Plugin => {\n\t// @ts-ignore: this might be anything, object or no\n\treturn Boolean(maybeInvalidPlugin?.isSwupPlugin);\n};\n\n/** Install a plugin. */\nexport const use = function (this: Swup, plugin: unknown) {\n\tif (!isSwupPlugin(plugin)) {\n\t\tconsole.error('Not a swup plugin instance', plugin);\n\t\treturn;\n\t}\n\n\tplugin.swup = this;\n\tif (plugin._checkRequirements) {\n\t\tif (!plugin._checkRequirements()) {\n\t\t\treturn;\n\t\t}\n\t}\n\tif (plugin._beforeMount) {\n\t\tplugin._beforeMount();\n\t}\n\tplugin.mount();\n\n\tthis.plugins.push(plugin);\n\n\treturn this.plugins;\n};\n\n/** Uninstall a plugin. */\nexport function unuse(this: Swup, pluginOrName: Plugin | string) {\n\tconst plugin = this.findPlugin(pluginOrName);\n\tif (!plugin) {\n\t\tconsole.error('No such plugin', plugin);\n\t\treturn;\n\t}\n\n\tplugin.unmount();\n\tif (plugin._afterUnmount) {\n\t\tplugin._afterUnmount();\n\t}\n\n\tthis.plugins = this.plugins.filter((p) => p !== plugin);\n\n\treturn this.plugins;\n}\n\n/** Find a plugin by name or reference. */\nexport function findPlugin(this: Swup, pluginOrName: Plugin | string) {\n\treturn this.plugins.find(\n\t\t(plugin) =>\n\t\t\tplugin === pluginOrName ||\n\t\t\tplugin.name === pluginOrName ||\n\t\t\tplugin.name === `Swup${String(pluginOrName)}`\n\t);\n}\n", "import type Swup from '../Swup.js';\n\n/**\n * Utility function to validate and run the global option 'resolveUrl'\n * @param {string} url\n * @returns {string} the resolved url\n */\nexport function resolveUrl(this: Swup, url: string): string {\n\tif (typeof this.options.resolveUrl !== 'function') {\n\t\tconsole.warn(`[swup] options.resolveUrl expects a callback function.`);\n\t\treturn url;\n\t}\n\tconst result = this.options.resolveUrl(url);\n\tif (!result || typeof result !== 'string') {\n\t\tconsole.warn(`[swup] options.resolveUrl needs to return a url`);\n\t\treturn url;\n\t}\n\tif (result.startsWith('//') || result.startsWith('http')) {\n\t\tconsole.warn(`[swup] options.resolveUrl needs to return a relative url`);\n\t\treturn url;\n\t}\n\treturn result;\n}\n\n/**\n * Compares the resolved version of two paths and returns true if they are the same\n * @param {string} url1\n * @param {string} url2\n * @returns {boolean}\n */\nexport function isSameResolvedUrl(this: Swup, url1: string, url2: string): boolean {\n\treturn this.resolveUrl(url1) === this.resolveUrl(url2);\n}\n", "import { type DelegateEvent } from 'delegate-it';\n\nimport version from './config/version.js';\n\nimport { delegateEvent, getCurrentUrl, Location, updateHistoryRecord } from './helpers.js';\nimport { type DelegateEventUnsubscribe } from './helpers/delegateEvent.js';\n\nimport { Cache } from './modules/Cache.js';\nimport { Classes } from './modules/Classes.js';\nimport { type Visit, createVisit } from './modules/Visit.js';\nimport { Hooks, type HookName, type HookInitOptions } from './modules/Hooks.js';\nimport { getAnchorElement } from './modules/getAnchorElement.js';\nimport { awaitAnimations } from './modules/awaitAnimations.js';\nimport { navigate, performNavigation, type NavigationToSelfAction } from './modules/navigate.js';\nimport { fetchPage } from './modules/fetchPage.js';\nimport { animatePageOut } from './modules/animatePageOut.js';\nimport { replaceContent } from './modules/replaceContent.js';\nimport { scrollToContent } from './modules/scrollToContent.js';\nimport { animatePageIn } from './modules/animatePageIn.js';\nimport { renderPage } from './modules/renderPage.js';\nimport { use, unuse, findPlugin, type Plugin } from './modules/plugins.js';\nimport { isSameResolvedUrl, resolveUrl } from './modules/resolveUrl.js';\nimport { nextTick } from './utils.js';\nimport { type HistoryState } from './helpers/history.js';\n\n/** Options for customizing swup's behavior. */\nexport type Options = {\n\t/** Whether history visits are animated. Default: `false` */\n\tanimateHistoryBrowsing: boolean;\n\t/** Selector for detecting animation timing. Default: `[class*=\"transition-\"]` */\n\tanimationSelector: string | false;\n\t/** Elements on which to add animation classes. Default: `html` element */\n\tanimationScope: 'html' | 'containers';\n\t/** Enable in-memory page cache. Default: `true` */\n\tcache: boolean;\n\t/** Content containers to be replaced on page visits. Default: `['#swup']` */\n\tcontainers: string[];\n\t/** Callback for ignoring visits. Receives the element and event that triggered the visit. */\n\tignoreVisit: (url: string, { el, event }: { el?: Element; event?: Event }) => boolean;\n\t/** Selector for links that trigger visits. Default: `'a[href]'` */\n\tlinkSelector: string;\n\t/** How swup handles links to the same page. Default: `scroll` */\n\tlinkToSelf: NavigationToSelfAction;\n\t/** Enable native animations using the View Transitions API. */\n\tnative: boolean;\n\t/** Hook handlers to register. */\n\thooks: Partial<HookInitOptions>;\n\t/** Plugins to register on startup. */\n\tplugins: Plugin[];\n\t/** Custom headers sent along with fetch requests. */\n\trequestHeaders: Record<string, string>;\n\t/** Rewrite URLs before loading them. */\n\tresolveUrl: (url: string) => string;\n\t/** Callback for telling swup to ignore certain popstate events.  */\n\tskipPopStateHandling: (event: PopStateEvent) => boolean;\n\t/** Request timeout in milliseconds. */\n\ttimeout: number;\n};\n\nconst defaults: Options = {\n\tanimateHistoryBrowsing: false,\n\tanimationSelector: '[class*=\"transition-\"]',\n\tanimationScope: 'html',\n\tcache: true,\n\tcontainers: ['#swup'],\n\thooks: {},\n\tignoreVisit: (url, { el } = {}) => !!el?.closest('[data-no-swup]'),\n\tlinkSelector: 'a[href]',\n\tlinkToSelf: 'scroll',\n\tnative: false,\n\tplugins: [],\n\tresolveUrl: (url) => url,\n\trequestHeaders: {\n\t\t'X-Requested-With': 'swup',\n\t\t'Accept': 'text/html, application/xhtml+xml'\n\t},\n\tskipPopStateHandling: (event) => (event.state as HistoryState)?.source !== 'swup',\n\ttimeout: 0\n};\n\n/** Swup page transition library. */\nexport default class Swup {\n\t/** Library version */\n\treadonly version: string = version;\n\t/** Options passed into the instance */\n\toptions: Options;\n\t/** Default options before merging user options */\n\treadonly defaults: Options = defaults;\n\t/** Registered plugin instances */\n\tplugins: Plugin[] = [];\n\t/** Data about the current visit */\n\tvisit: Visit;\n\t/** Cache instance */\n\treadonly cache: Cache;\n\t/** Hook registry */\n\treadonly hooks: Hooks;\n\t/** Animation class manager */\n\treadonly classes: Classes;\n\t/** Location of the currently visible page */\n\tlocation: Location = Location.fromUrl(window.location.href);\n\t/** URL of the currently visible page @deprecated Use swup.location.url instead */\n\tget currentPageUrl(): string {\n\t\treturn this.location.url;\n\t}\n\t/** Index of the current history entry */\n\tprotected currentHistoryIndex: number;\n\t/** Delegated event subscription handle */\n\tprotected clickDelegate?: DelegateEventUnsubscribe;\n\t/** Navigation status */\n\tprotected navigating: boolean = false;\n\t/** Run anytime a visit ends */\n\tprotected onVisitEnd?: () => Promise<unknown>;\n\n\t/** Install a plugin */\n\tuse = use;\n\t/** Uninstall a plugin */\n\tunuse = unuse;\n\t/** Find a plugin by name or instance */\n\tfindPlugin = findPlugin;\n\n\t/** Log a message. Has no effect unless debug plugin is installed */\n\tlog: (message: string, context?: unknown) => void = () => {};\n\n\t/** Navigate to a new URL */\n\tnavigate = navigate;\n\t/** Actually perform a navigation */\n\tprotected performNavigation = performNavigation;\n\t/** Create a new context for this visit */\n\tprotected createVisit = createVisit;\n\t/** Register a delegated event listener */\n\tdelegateEvent = delegateEvent;\n\t/** Fetch a page from the server */\n\tfetchPage = fetchPage;\n\t/** Resolve when animations on the page finish */\n\tawaitAnimations = awaitAnimations;\n\tprotected renderPage = renderPage;\n\t/** Replace the content after page load */\n\treplaceContent = replaceContent;\n\tprotected animatePageIn = animatePageIn;\n\tprotected animatePageOut = animatePageOut;\n\tprotected scrollToContent = scrollToContent;\n\t/** Find the anchor element for a given hash */\n\tgetAnchorElement = getAnchorElement;\n\n\t/** Get the current page URL */\n\tgetCurrentUrl = getCurrentUrl;\n\t/** Resolve a URL to its final location */\n\tresolveUrl = resolveUrl;\n\t/** Check if two URLs resolve to the same location */\n\tprotected isSameResolvedUrl = isSameResolvedUrl;\n\n\tconstructor(options: Partial<Options> = {}) {\n\t\t// Merge defaults and options\n\t\tthis.options = { ...this.defaults, ...options };\n\n\t\tthis.handleLinkClick = this.handleLinkClick.bind(this);\n\t\tthis.handlePopState = this.handlePopState.bind(this);\n\n\t\tthis.cache = new Cache(this);\n\t\tthis.classes = new Classes(this);\n\t\tthis.hooks = new Hooks(this);\n\t\tthis.visit = this.createVisit({ to: '' });\n\n\t\tthis.currentHistoryIndex = (window.history.state as HistoryState)?.index ?? 1;\n\n\t\tthis.enable();\n\t}\n\n\t/** Enable this instance, adding listeners and classnames. */\n\tasync enable() {\n\t\t// Add event listener\n\t\tconst { linkSelector } = this.options;\n\t\tthis.clickDelegate = this.delegateEvent(linkSelector, 'click', this.handleLinkClick);\n\n\t\twindow.addEventListener('popstate', this.handlePopState);\n\n\t\t// Set scroll restoration to manual if animating history visits\n\t\tif (this.options.animateHistoryBrowsing) {\n\t\t\twindow.history.scrollRestoration = 'manual';\n\t\t}\n\n\t\t// Initial save to cache\n\t\tif (this.options.cache) {\n\t\t\t// Disabled to avoid caching modified dom state: logic moved to preload plugin\n\t\t\t// https://github.com/swup/swup/issues/475\n\t\t}\n\n\t\t// Sanitize/check native option\n\t\tthis.options.native = this.options.native && !!document.startViewTransition;\n\n\t\t// Mount plugins\n\t\tthis.options.plugins.forEach((plugin) => this.use(plugin));\n\n\t\t// Install user hooks\n\t\tfor (const [key, handler] of Object.entries(this.options.hooks)) {\n\t\t\t// Build hook options from modifier suffix: 'content:replace.before' => { before: true }\n\t\t\tconst [hook, modifiers] = this.hooks.parseName(key as HookName);\n\t\t\t// @ts-expect-error: object.entries() does not preserve key/value types\n\t\t\tthis.hooks.on(hook, handler, modifiers);\n\t\t}\n\n\t\t// Create initial history record\n\t\tif ((window.history.state as HistoryState)?.source !== 'swup') {\n\t\t\tupdateHistoryRecord(null, { index: this.currentHistoryIndex });\n\t\t}\n\n\t\t// Give consumers a chance to hook into enable\n\t\tawait nextTick();\n\n\t\t// Trigger enable hook\n\t\tawait this.hooks.call('enable', undefined, undefined, () => {\n\t\t\tconst html = document.documentElement;\n\t\t\thtml.classList.add('swup-enabled');\n\t\t\thtml.classList.toggle('swup-native', this.options.native);\n\t\t});\n\t}\n\n\t/** Disable this instance, removing listeners and classnames. */\n\tasync destroy() {\n\t\t// remove delegated listener\n\t\tthis.clickDelegate!.destroy();\n\n\t\t// remove popstate listener\n\t\twindow.removeEventListener('popstate', this.handlePopState);\n\n\t\t// empty cache\n\t\tthis.cache.clear();\n\n\t\t// unmount plugins\n\t\tthis.options.plugins.forEach((plugin) => this.unuse(plugin));\n\n\t\t// trigger disable hook\n\t\tawait this.hooks.call('disable', undefined, undefined, () => {\n\t\t\tconst html = document.documentElement;\n\t\t\thtml.classList.remove('swup-enabled');\n\t\t\thtml.classList.remove('swup-native');\n\t\t});\n\n\t\t// remove handlers\n\t\tthis.hooks.clear();\n\t}\n\n\t/** Determine if a visit should be ignored by swup, based on URL or trigger element. */\n\tshouldIgnoreVisit(href: string, { el, event }: { el?: Element; event?: Event } = {}) {\n\t\tconst { origin, url, hash } = Location.fromUrl(href);\n\n\t\t// Ignore if the new origin doesn't match the current one\n\t\tif (origin !== window.location.origin) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ignore if the link/form would open a new window (or none at all)\n\t\tif (el && this.triggerWillOpenNewWindow(el)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ignore if the visit should be ignored as per user options\n\t\tif (this.options.ignoreVisit(url + hash, { el, event })) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Finally, allow the visit\n\t\treturn false;\n\t}\n\n\tprotected handleLinkClick(event: DelegateEvent<MouseEvent>) {\n\t\tconst el = event.delegateTarget as HTMLAnchorElement;\n\t\tconst { href, url, hash } = Location.fromElement(el);\n\n\t\t// Exit early if the link should be ignored\n\t\tif (this.shouldIgnoreVisit(href, { el, event })) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Ignore if swup is currently navigating towards the link's URL\n\t\tif (this.navigating && url === this.visit.to.url) {\n\t\t\tevent.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tconst visit = this.createVisit({ to: url, hash, el, event });\n\n\t\t// Exit early if control key pressed\n\t\tif (event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {\n\t\t\tthis.hooks.callSync('link:newtab', visit, { href });\n\t\t\treturn;\n\t\t}\n\n\t\t// Exit early if other than left mouse button\n\t\tif (event.button !== 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.hooks.callSync('link:click', visit, { el, event }, () => {\n\t\t\tconst from = visit.from.url ?? '';\n\n\t\t\tevent.preventDefault();\n\n\t\t\t// Handle links to the same page\n\t\t\tif (!url || url === from) {\n\t\t\t\tif (hash) {\n\t\t\t\t\t// With hash: scroll to anchor\n\t\t\t\t\tthis.hooks.callSync('link:anchor', visit, { hash }, () => {\n\t\t\t\t\t\tupdateHistoryRecord(url + hash);\n\t\t\t\t\t\tthis.scrollToContent(visit);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\t// Without hash: scroll to top or load/reload page\n\t\t\t\t\tthis.hooks.callSync('link:self', visit, undefined, () => {\n\t\t\t\t\t\tif (this.options.linkToSelf === 'navigate') {\n\t\t\t\t\t\t\tthis.performNavigation(visit);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tupdateHistoryRecord(url);\n\t\t\t\t\t\t\tthis.scrollToContent(visit);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Exit early if the resolved path hasn't changed\n\t\t\tif (this.isSameResolvedUrl(url, from)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Finally, proceed with loading the page\n\t\t\tthis.performNavigation(visit);\n\t\t});\n\t}\n\n\tprotected handlePopState(event: PopStateEvent) {\n\t\tconst href: string = (event.state as HistoryState)?.url ?? window.location.href;\n\n\t\t// Exit early if this event should be ignored\n\t\tif (this.options.skipPopStateHandling(event)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Exit early if the resolved path hasn't changed\n\t\tif (this.isSameResolvedUrl(getCurrentUrl(), this.location.url)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { url, hash } = Location.fromUrl(href);\n\n\t\tconst visit = this.createVisit({ to: url, hash, event });\n\n\t\t// Mark as history visit\n\t\tvisit.history.popstate = true;\n\n\t\t// Determine direction of history visit\n\t\tconst index = (event.state as HistoryState)?.index ?? 0;\n\t\tif (index && index !== this.currentHistoryIndex) {\n\t\t\tconst direction = index - this.currentHistoryIndex > 0 ? 'forwards' : 'backwards';\n\t\t\tvisit.history.direction = direction;\n\t\t\tthis.currentHistoryIndex = index;\n\t\t}\n\n\t\t// Disable animation & scrolling for history visits\n\t\tvisit.animation.animate = false;\n\t\tvisit.scroll.reset = false;\n\t\tvisit.scroll.target = false;\n\n\t\t// Animated history visit: re-enable animation & scroll reset\n\t\tif (this.options.animateHistoryBrowsing) {\n\t\t\tvisit.animation.animate = true;\n\t\t\tvisit.scroll.reset = true;\n\t\t}\n\n\t\tthis.hooks.callSync('history:popstate', visit, { event }, () => {\n\t\t\tthis.performNavigation(visit);\n\t\t});\n\t}\n\n\t/** Determine whether an element will open a new tab when clicking/activating. */\n\tprotected triggerWillOpenNewWindow(triggerEl: Element) {\n\t\tif (triggerEl.matches('[download], [target=\"_blank\"]')) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n", "type Comparator = '>' | '>=' | '<' | '<=';\n\n// Fill versions to exactly 3 decimals\nexport const normalizeVersion = (version: string): string => {\n\treturn String(version)\n\t\t.split('.')\n\t\t.map(segment => String(parseInt(segment || '0', 10)))\n\t\t.concat(['0', '0'])\n\t\t.slice(0, 3)\n\t\t.join('.');\n};\n\n// Numerically compare version strings after normalizing them\nexport const compareVersion = (a: string, b: string): number => {\n\ta = normalizeVersion(a);\n\tb = normalizeVersion(b);\n\treturn a.localeCompare(b, undefined, { numeric: true });\n};\n\n// Apply a comparator (equals, greater-than, etc) by its symbol to a sort comparison\nconst applyComparator = (comparisonResult: number, comparator: Comparator) => {\n\tconst comparators = {\n\t\t'': (r: number) => r === 0,\n\t\t'>': (r: number) => r > 0,\n\t\t'>=': (r: number) => r >= 0,\n\t\t'<': (r: number) => r < 0,\n\t\t'<=': (r: number) => r <= 0\n\t};\n\tconst comparatorFn = comparators[comparator] || comparators[''];\n\treturn comparatorFn(comparisonResult);\n};\n\n/**\n * Check if a version satisfies all given version requirements\n *\n * versionSatisfies('2.1.0', ['>=2', '<4']) // true\n * versionSatisfies('2.1.0', ['5']) // false\n *\n * @param {string} installed Installed version\n * @param {Array.<string>} requirements Array of requirements that must be satisfied\n * @returns boolean\n */\nexport const versionSatisfies = (installed: string, requirements: string[]) => {\n\treturn requirements.every((required) => {\n\t\tconst [, comparator, version] = required.match(/^([\\D]+)?(.*)$/) || [];\n\t\tconst comparisonResult = compareVersion(installed, version);\n\t\treturn applyComparator(comparisonResult, (comparator as Comparator) || '>=');\n\t});\n};\n", "import type Swup from 'swup';\nimport type { Plugin, HookName, HookOptions, HookUnregister, Handler } from 'swup';\nimport { checkDependencyVersion } from './pluginRequirements.js';\n\nfunction isBound(func: Function) {\n\treturn func.name.startsWith('bound ') && !func.hasOwnProperty('prototype');\n}\n\nexport default abstract class SwupPlugin implements Plugin {\n\t/** Name of the plugin */\n\tabstract name: string;\n\n\t/** Identify as a swup plugin */\n\tisSwupPlugin: true = true;\n\n\t// Swup instance, assigned by swup itself\n\tswup!: Swup;\n\n\t/** Version of this plugin. Currently not in use, defined here for backward compatiblity. */\n\tversion?: string;\n\n\t/** Version requirements of this plugin. Example: `{ swup: '>=4' }` */\n\trequires?: Record<string, string | string[]> = {};\n\n\t// List of hook handlers to unregister on unmount\n\tprivate handlersToUnregister: HookUnregister[] = [];\n\n\t/** Run on mount */\n\tmount() {\n\t\t// this is mount method rewritten by class extending\n\t\t// and is executed when swup is enabled with plugin\n\t}\n\n\t/** Run on unmount */\n\tunmount() {\n\t\t// this is unmount method rewritten by class extending\n\t\t// and is executed when swup with plugin is disabled\n\n\t\t// Unsubscribe all registered hook handlers\n\t\tthis.handlersToUnregister.forEach((unregister) => unregister());\n\t\tthis.handlersToUnregister = [];\n\t}\n\n\t_beforeMount(): void {\n\t\tif (!this.name) {\n\t\t\tthrow new Error('You must define a name of plugin when creating a class.');\n\t\t}\n\t}\n\n\t_afterUnmount(): void {\n\t\t// here for any future hidden auto-cleanup\n\t}\n\n\t_checkRequirements(): boolean {\n\t\tif (typeof this.requires !== 'object') {\n\t\t\treturn true;\n\t\t}\n\n\t\tObject.entries(this.requires).forEach(([dependency, versions]) => {\n\t\t\tversions = Array.isArray(versions) ? versions : [versions];\n\t\t\tif (!checkDependencyVersion(dependency, versions, this.swup)) {\n\t\t\t\tconst requirement = `${dependency} ${versions.join(', ')}`;\n\t\t\t\tthrow new Error(`Plugin version mismatch: ${this.name} requires ${requirement}`);\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Register a new hook handler.\n\t *\n\t * On plugin unmount, the handler will automatically be unregistered.\n\t * The handler function is lexically bound to the plugin instance for convenience.\n\t * @see swup.hooks.on\n\t */\n\tprotected on<T extends HookName>(hook: T, handler: Handler<T>, options: HookOptions = {}): HookUnregister {\n\t\thandler = !isBound(handler) ? handler.bind(this) : handler;\n\t\tconst unregister = this.swup.hooks.on(hook, handler, options);\n\t\tthis.handlersToUnregister.push(unregister);\n\t\treturn unregister;\n\t}\n\n\tprotected once<T extends HookName>(hook: T, handler: Handler<T>, options: HookOptions = {}): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, once: true });\n\t}\n\n\tprotected before<T extends HookName>(hook: T, handler: Handler<T>, options: HookOptions = {}): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, before: true });\n\t}\n\n\tprotected replace<T extends HookName>(hook: T, handler: Handler<T>, options: HookOptions = {}): HookUnregister {\n\t\treturn this.on(hook, handler, { ...options, replace: true });\n\t}\n\n\tprotected off<T extends HookName>(hook: T, handler?: Handler<T>): void {\n\t\treturn this.swup.hooks.off(hook, handler!);\n\t}\n}\n", "import type Swup from 'swup';\n\nimport { versionSatisfies } from './versionSatisfies.js';\n\nfunction getInstalledDependencyVersion(dependency: string, swup: Swup): string {\n\tif (dependency === 'swup') {\n\t\treturn swup.version ?? '';\n\t} else {\n\t\t// Circular type dependency?\n\t\t// findPlugin returns swup's Plugin type which is not up-to-date\n\t\t// with the actual Plugin type from index.ts\n\t\tconst plugin = swup.findPlugin(dependency);\n\t\treturn plugin?.version ?? '';\n\t}\n}\n\nexport function checkDependencyVersion(\n\tdependency: string,\n\trequirements: string[],\n\tswup: Swup\n): boolean {\n\tconst version = getInstalledDependencyVersion(dependency, swup);\n\tif (version) {\n\t\treturn versionSatisfies(version, requirements);\n\t} else {\n\t\treturn false;\n\t}\n}\n", "import Plugin from '@swup/plugin';\n\nexport default abstract class Theme extends Plugin {\n\t_originalAnimationSelectorOption: string = '';\n\t_addedStyleElements: Element[] = [];\n\t_addedHTMLContent: Element[] = [];\n\t_classNameAddedToElements: ({ selector: string, name: string })[] = [];\n\n\t_beforeMount() {\n\t\t// Store original animationSelector option, then replace it\n\t\tthis._originalAnimationSelectorOption = String(this.swup.options.animationSelector);\n\t\tthis.swup.options.animationSelector = '[class*=\"swup-transition-\"]';\n\n\t\t// Add classes after each content replace\n\t\tthis.swup.hooks.on('content:replace', this._addClassNameToElement);\n\t}\n\n\t_afterUnmount() {\n\t\t// Restore original animationSelector option\n\t\tthis.swup.options.animationSelector = this._originalAnimationSelectorOption;\n\n\t\t// Remove added styles\n\t\tthis._addedStyleElements.forEach((element) => {\n\t\t\telement.outerHTML = '';\n\t\t});\n\t\tthis._addedStyleElements = [];\n\n\t\t// Remove added HTML\n\t\tthis._addedHTMLContent.forEach((element) => {\n\t\t\telement.outerHTML = '';\n\t\t});\n\t\tthis._addedHTMLContent = [];\n\n\t\t// Remove added classnames\n\t\tthis._classNameAddedToElements.forEach((item) => {\n\t\t\tconst elements = Array.from(document.querySelectorAll(item.selector));\n\t\t\telements.forEach((element) => {\n\t\t\t\telement.className.split(' ').forEach((classItem) => {\n\t\t\t\t\tif (new RegExp('^swup-transition-').test(classItem)) {\n\t\t\t\t\t\telement.classList.remove(classItem);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tthis.swup.hooks.off('content:replace', this._addClassNameToElement);\n\t}\n\n\tapplyStyles(styles: string) {\n\t\tconst style = document.createElement('style');\n\t\tstyle.setAttribute('data-swup-theme', '');\n\t\tstyle.appendChild(document.createTextNode(styles));\n\t\tdocument.head.prepend(style);\n\n\t\tthis._addedStyleElements.push(style);\n\t}\n\n\tapplyHTML(content: string) {\n\t\tconst element = document.createElement('div');\n\t\telement.innerHTML = content;\n\t\tdocument.body.appendChild(element);\n\n\t\tthis._addedHTMLContent.push(element);\n\t}\n\n\taddClassName(selector: string, name: string) {\n\t\t// save so it can be later removed\n\t\tthis._classNameAddedToElements.push({ selector, name });\n\n\t\t// add class the first time\n\t\tthis._addClassNameToElement();\n\t}\n\n\t_addClassNameToElement = () => {\n\t\tthis._classNameAddedToElements.forEach((item) => {\n\t\t\tconst elements = Array.from(document.querySelectorAll(item.selector));\n\t\t\telements.forEach((element) => {\n\t\t\t\telement.classList.add(`swup-transition-${item.name}`);\n\t\t\t});\n\t\t});\n\t};\n}\n", "import Theme from '@swup/theme';\nimport styles from './index.css';\n\nexport default class SwupFadeTheme extends Theme {\n\tname = 'SwupFadeTheme';\n\n\tdefaults = {\n\t\tmainElement: '#swup'\n\t};\n\n\tconstructor(options = {}) {\n\t\tsuper();\n\t\tthis.options = { ...this.defaults, ...options };\n\t}\n\n\tmount() {\n\t\tthis.applyStyles(styles);\n\t\tthis.addClassName(this.options.mainElement, 'main');\n\t}\n}\n", "import Swup from 'swup';\r\nimport SwupFadeTheme from '@swup/fade-theme';\r\n\r\nconst swup = new Swup({\r\n  plugins: [new SwupFadeTheme()],\r\n});\r\n\r\nswup.hooks.on('visit:start', () => {\r\n  console.log('Navigating to:', window.location.href);\r\n});\r\n"],
  "mappings": "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",
  "names": ["classify", "text", "fallback", "String", "toLowerCase", "replace", "getCurrentUrl", "hash", "window", "location", "pathname", "search", "createHistoryRecord", "url", "data", "state", "_extends", "random", "Math", "source", "history", "pushState", "updateHistoryRecord", "currentState", "replaceState", "delegateEvent", "selector", "type", "callback", "options", "controller", "AbortController", "signal", "delegate", "destroy", "abort", "Location", "URL", "constructor", "base", "document", "baseURI", "super", "toString", "Object", "setPrototypeOf", "this", "prototype", "el", "href", "getAttribute", "FetchError", "Error", "constructor", "message", "details", "super", "this", "url", "status", "aborted", "timedOut", "name", "async", "fetchPage", "options", "_options$timeout", "Location", "fromUrl", "visit", "headers", "_extends", "requestHeaders", "timeout", "controller", "AbortController", "signal", "response", "timeoutId", "setTimeout", "abort", "hooks", "call", "fetch", "clearTimeout", "error", "responseUrl", "html", "text", "finalUrl", "page", "cache", "write", "method", "set", "Cache", "swup", "pages", "Map", "size", "all", "copy", "forEach", "key", "has", "resolve", "get", "result", "callSync", "update", "payload", "delete", "clear", "undefined", "prune", "predicate", "urlToResolve", "resolveUrl", "query", "selector", "context", "document", "querySelector", "queryAll", "Array", "from", "querySelectorAll", "nextTick", "Promise", "requestAnimationFrame", "isPromise", "obj", "then", "runAsPromise", "func", "args", "reject", "getContextualAttr", "el", "attr", "target", "closest", "hasAttribute", "getAttribute", "Classes", "constructor", "swup", "this", "swupClasses", "selectors", "scope", "visit", "animation", "containers", "Array", "isArray", "selector", "join", "targets", "trim", "queryAll", "add", "classes", "forEach", "classList", "remove", "clear", "className", "split", "filter", "c", "isSwupClass", "some", "startsWith", "Visit", "options", "id", "state", "from", "to", "trigger", "cache", "history", "scroll", "meta", "hash", "event", "Math", "random", "url", "location", "animate", "wait", "name", "native", "animationScope", "animationSelector", "read", "write", "action", "popstate", "direction", "undefined", "reset", "advance", "abort", "done", "createVisit", "Hooks", "registry", "Map", "hooks", "init", "hook", "create", "has", "set", "exists", "get", "ledger", "console", "error", "on", "handler", "warn", "registration", "_extends", "size", "off", "before", "replace", "once", "delete", "arg1", "arg2", "arg3", "args", "defaultHandler", "parseCallArgs", "after", "getHandlers", "run", "result", "dispatchDomEvent", "callSync", "runSync", "registrations", "rethrow", "results", "runAsPromise", "push", "isPromise", "found", "replaced", "values", "sort", "sortRegistrations", "T", "length", "index", "replacingHandler", "createDefaultHandler", "next", "a", "b", "_a$priority", "_b$priority", "priority", "detail", "document", "dispatchEvent", "CustomEvent", "bubbles", "parseName", "modifiers", "reduce", "acc", "mod", "getAnchorElement", "charAt", "substring", "decoded", "decodeURIComponent", "element", "getElementById", "query", "CSS", "escape", "body", "TRANSITION", "ANIMATION", "async", "awaitAnimations", "elements", "animatedElements", "awaitedAnimations", "map", "type", "timeout", "propCount", "styles", "window", "getComputedStyle", "transitionDelays", "getStyleProperties", "transitionDurations", "transitionTimeout", "calculateTimeout", "animationDelays", "animationDurations", "animationTimeout", "max", "Promise", "resolve", "endEvent", "startTime", "performance", "now", "propsTransitioned", "end", "removeEventListener", "onEnd", "elapsedTime", "setTimeout", "addEventListener", "Boolean", "all", "key", "delays", "durations", "concat", "duration", "i", "toMs", "time", "parseFloat", "navigate", "Error", "shouldIgnoreVisit", "assign", "Location", "fromUrl", "performNavigation", "navigating", "onVisitEnd", "call", "referrer", "includes", "_options$cache$read", "_options$cache$write", "page", "cachedPage", "fetchPage", "then", "html", "DOMParser", "parseFromString", "newUrl", "updateHistoryRecord", "currentHistoryIndex", "createHistoryRecord", "classify", "renderPage", "animatePageOut", "startViewTransition", "finished", "animatePageIn", "aborted", "skipPopStateHandling", "back", "skip", "replaceContent", "_incomingDocument$que", "incomingDocument", "title", "querySelector", "innerText", "persistedElements", "currentEl", "incomingEl", "replaceWith", "cloneNode", "existing", "replacement", "scrollToContent", "behavior", "scrollTarget", "scrolled", "anchor", "scrollIntoView", "scrollTo", "top", "left", "nextTick", "isSameResolvedUrl", "getCurrentUrl", "use", "plugin", "maybeInvalidPlugin", "isSwupPlugin", "_checkRequirements", "_beforeMount", "mount", "plugins", "unuse", "pluginOrName", "findPlugin", "unmount", "_afterUnmount", "p", "find", "String", "resolveUrl", "url1", "url2", "defaults", "animateHistoryBrowsing", "ignoreVisit", "linkSelector", "linkToSelf", "requestHeaders", "Accept", "_event$state", "source", "Swup", "currentPageUrl", "_window$history$state", "_window$history$state2", "version", "href", "clickDelegate", "log", "delegateEvent", "handleLinkClick", "bind", "handlePopState", "Cache", "enable", "_window$history$state3", "scrollRestoration", "Object", "entries", "documentElement", "toggle", "destroy", "origin", "triggerWillOpenNewWindow", "delegateTarget", "fromElement", "preventDefault", "metaKey", "ctrlKey", "shiftKey", "altKey", "button", "_visit$from$url", "_event$state$url", "_event$state2", "_event$state$index", "_event$state3", "triggerEl", "matches", "normalizeVersion", "version", "String", "split", "map", "segment", "parseInt", "concat", "slice", "join", "SwupPlugin", "constructor", "this", "isSwupPlugin", "swup", "requires", "handlersToUnregister", "mount", "unmount", "forEach", "unregister", "_beforeMount", "name", "Error", "_afterUnmount", "_checkRequirements", "Object", "entries", "dependency", "versions", "requirements", "_swup$version", "_plugin$version", "plugin", "findPlugin", "versionSatisfies", "installed", "every", "required", "comparator", "match", "compareVersion", "a", "b", "applyComparator", "comparisonResult", "comparators", "r", "localeCompare", "numeric", "Array", "isArray", "requirement", "on", "hook", "handler", "options", "func", "startsWith", "hasOwnProperty", "bind", "hooks", "push", "once", "_extends", "before", "replace", "off", "Theme", "Plugin", "constructor", "args", "this", "_originalAnimationSelectorOption", "_addedStyleElements", "_addedHTMLContent", "_classNameAddedToElements", "_addClassNameToElement", "forEach", "item", "Array", "from", "document", "querySelectorAll", "selector", "element", "classList", "add", "name", "_beforeMount", "String", "swup", "options", "animationSelector", "hooks", "on", "_afterUnmount", "outerHTML", "className", "split", "classItem", "RegExp", "test", "remove", "off", "applyStyles", "styles", "style", "createElement", "setAttribute", "appendChild", "createTextNode", "head", "prepend", "push", "applyHTML", "content", "innerHTML", "body", "addClassName", "SwupFadeTheme", "Theme", "constructor", "options", "super", "this", "name", "defaults", "mainElement", "_extends", "mount", "applyStyles", "addClassName", "n"]
}
